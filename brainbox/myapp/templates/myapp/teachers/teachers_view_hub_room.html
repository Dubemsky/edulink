{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>{{ hub }} - EduLink</title>
  <meta name="description" content="EduLink teacher hub room - manage your classroom and interact with students">
  <meta name="keywords" content="education, teaching, classroom management">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- jQuery -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- Vendor CSS Files -->
  <link href="{% static 'vendor/bootstrap/css/bootstrap.min.css' %}" rel="stylesheet">
  <link href="{% static 'vendor/bootstrap-icons/bootstrap-icons.css' %}" rel="stylesheet">
  <link href="{% static 'vendor/aos/aos.css' %}" rel="stylesheet">
  <link href="{% static 'vendor/glightbox/css/glightbox.min.css' %}" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <link href="{% static 'vendor/swiper/swiper-bundle.min.css' %}" rel="stylesheet">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

  <!-- Main CSS Files -->
  <link href="{% static 'css/main.css' %}" rel="stylesheet">
  <link href="{% static 'css/hub_room.css' %}" rel="stylesheet">
  <link href="{% static 'css/private_message.css' %}" rel="stylesheet">
  <link rel="icon" href="{% static 'favicon.ico' %}" type="image/x-icon">

  <style>
    

/* Add these styles to your CSS file */

/* Invite Modal Styles */
.student-list {
  max-height: 300px;
  overflow-y: auto;
  margin-top: 10px;
  padding: 5px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
}

.student-button {
  display: flex;
  align-items: center;
  width: 100%;
  background-color: #f8f9fa;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  padding: 8px 12px;
  margin-bottom: 8px;
  text-align: left;
  transition: all 0.2s;
  cursor: pointer;
}

.student-button:hover {
  background-color: #e9ecef;
  border-color: #ced4da;
}

.student-button.active {
  background-color: #e3f2fd;
  border-color: #90caf9;
}

.student-profile-pic {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: cover;
  margin-right: 12px;
}

.student-info {
  flex: 1;
}

.student-name {
  font-weight: 500;
  margin-bottom: 2px;
}

.student-email {
  font-size: 0.85rem;
  color: #6c757d;
}

.searching-indicator {
  text-align: center;
  padding: 10px;
  color: #6c757d;
}

.no-results {
  text-align: center;
  padding: 15px;
  color: #6c757d;
  font-style: italic;
}

.error {
  color: #dc3545;
  padding: 10px;
  text-align: center;
}

/* Notification Styles */
.notification-card {
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  padding: 15px;
  margin-bottom: 15px;
  transition: opacity 0.3s, height 0.3s;
}

.notification-header {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
}

.notification-icon {
  width: 32px;
  height: 32px;
  background-color: #e3f2fd;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 12px;
}

.notification-icon i {
  color: #2196f3;
  font-size: 1rem;
}

.notification-title {
  font-weight: 600;
  margin: 0;
  font-size: 1rem;
}

.notification-content {
  margin-bottom: 15px;
  color: #212529;
}

.notification-actions {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

.notification-actions button {
  padding: 6px 12px;
  border-radius: 4px;
  font-weight: 500;
  border: none;
  cursor: pointer;
  transition: background-color 0.2s;
}

.accept-btn {
  background-color: #4CAF50;
  color: white;
}

.accept-btn:hover {
  background-color: #3d8b40;
}

.reject-btn {
  background-color: #f44336;
  color: white;
}

.reject-btn:hover {
  background-color: #d32f2f;
}

.notification-timestamp {
  font-size: 0.75rem;
  color: #6c757d;
  text-align: right;
  margin-top: 5px;
}

/* Responsive Styles */
@media (max-width: 768px) {
  .notification-actions {
      flex-direction: column;
      gap: 5px;
  }
  
  .notification-actions button {
      width: 100%;
  }
}


  </style>
</head>

<body class="index-page teacher-view">
  <header id="header" class="header d-flex align-items-center sticky-top">
    <div class="container-fluid container-xl d-flex align-items-center justify-content-between">
      <a href="{% url 'teachers_homepage' %}" class="logo d-flex align-items-center me-auto">
        <h1 class="sitename">EduLink</h1>
      </a>
      
      <h3 class="page-title">Teacher Room: {{ hub }}</h3>

      <nav id="navmenu" class="navmenu">
        <ul>
          <li><a data-bs-toggle="modal" data-bs-target="#analyticsModal" style="cursor: pointer;">
            <i class="bi bi-bar-chart-line"></i> Analytics
          </a></li>

          <li><a data-bs-toggle="modal" data-bs-target="#manageLivestreamModal" style="cursor: pointer;">
            <i class="bi bi-broadcast"></i> Manage Livestreams
          </a></li>

          {% if privacy_setting == "private" %}
            <li>
                <a data-bs-toggle="modal" data-bs-target="#inviteStudentModal" style="cursor: pointer;">
                <i class="bi bi-person-plus"></i> Invite Students
                </a>
            </li>
        {% endif %}


          <li><a href="{% url 'teachers_homepage' %}" class="active">
            <i class="bi bi-house"></i> Dashboard
          </a></li>
        </ul>
        <i class="mobile-nav-toggle d-xl-none bi bi-list"></i>
      </nav>
    </div>
  </header>

  <!-- Chat Room Section -->
  <section>
    <div class="container">
      <div class="rounded-container">
        <div class="chat-room">
          <!-- Chat Section -->
          <aside class="chat-section">
            <div class="chat-messages" id="chatMessages">
              {% if messages %}
                {% for message in messages %}
                  <div class="message-box 
                      {% if message.role == 'teacher' and message.sender == current_teachers_name %}
                          current-teacher-message
                      {% elif message.role == 'teacher' %}
                          teacher-message
                      {% else %}
                          student-message
                      {% endif %}"
                      data-message-id="{{ message.message_id }}"
                      {% if not message.is_poll %} onclick="openSidePanel('{{ message.content }}', this.dataset.messageId)" {% endif %}
                  >
                    <span class="message-sender">
                      {% if message.is_current_user %}
                        Me
                      {% else %}
                        {{ message.sender }}
                      {% endif %}
                    </span>
      
                    {% if message.image_url %}
                    <div class="message-image">
                      <a href="{{ message.image_url }}" target="_blank">
                        <img src="{{ message.image_url }}" alt="Shared image">
                      </a>
                    </div>
                    {% endif %}
      
                    {% if message.file_url %}
                    <div class="message-file">
                      <a href="{{ message.file_url }}" target="_blank">
                        <img src="/static/images/files.png" alt="File" style="width: 100px; height: 90px;">
                        <span>
                          {% if message.content and message.content != "my file" %}
                            {{ message.content }}
                          {% else %}
                            Download File
                          {% endif %}
                        </span>
                      </a>
                    </div>
                    {% endif %}
      
                    {% if message.video_url %}
                    <div class="message-video">
                      <video src="{{ message.video_url }}" controls></video>
                    </div>
                    {% endif %}
      
                    {% if message.content and not message.is_poll %}
                    <div class="message-text">
                      {{ message.content|linebreaksbr }}
                    </div>
                    {% endif %}
      
                    {% if message.is_poll %}
                    <div class="message-poll">
                      <strong>{{ message.content }}</strong>
                      <form id="poll-form-{{ message.message_id }}" data-message-id="{{ message.message_id }}" data-room-id="{{message.room_id}}">
                        <ul>
                          {% for option in message.poll_options %}
                            <li>
                              <input type="radio" id="option-{{ message.message_id }}-{{ forloop.counter }}" name="poll-option-{{ message.message_id }}" value="{{ option.option }}">
                              <label for="option-{{ message.message_id }}-{{ forloop.counter }}">{{ option.option }}</label>
                              <span class="vote-count" id="vote-count-{{ message.message_id }}-{{ forloop.counter }}">{{ option.votes }}</span>
                            </li>
                          {% endfor %}
                        </ul>
                        <button type="button" class="poll-vote-button" id="poll-vote-{{ message.message_id }}" onclick="submitPollVote('{{ message.message_id }}', '{{message.room_id}}')">Vote</button>
                      </form>
                    </div>
                    {% endif %}
      
                    {% if message.top_reply_content != 'No replies yet.' and not message.is_poll %}
                    <div class="top-reply">
                      <div class="top-reply-content">
                        <strong>Top Reply:</strong> {{ message.top_reply_content }}
                      </div>
                      <div class="top-reply-votes">
                        <span class="upvote" title="Upvote"></span> {{ message.top_reply_upvotes }} 
                        | 
                        <span class="downvote" title="Downvote"></span> {{ message.top_reply_downvotes }}
                      </div>
                    </div>
                    {% elif not message.is_poll %}
                    <div class="top-reply no-reply">
                      <em>No replies yet.</em>
                    </div>
                    {% endif %}
      
                    <span class="message-time">{{ message.created_at }}</span>
                  </div>
                {% endfor %}
              {% else %}
                <p class="no-messages">No messages yet. Start a conversation!</p>
              {% endif %}
            </div>
            
            <footer class="chat-input">
              <div class="input-group">
                <div style="position: relative; display: inline-block;">
                  <button type="button" id="attachFileButton" class="btn btn-light">
                    <i class="fa fa-plus"></i>
                  </button>
                
                  <!-- Mini GUI for Upload Options -->
                  <div id="upload-menu" class="dropdown-menu">
                    <button class="dropdown-item" id="upload-file">
                      <i class="fa fa-paperclip"></i> Share File
                    </button>
                    <button class="dropdown-item" id="upload-video">
                      <i class="fa fa-video-camera"></i> Share Video
                    </button>
                    <button class="dropdown-item" id="upload-poll">
                      <i class="fa fa-bar-chart"></i> Create Poll
                    </button>
                  </div>

                  <div id="poll-gui" style="display: none;">
                    <label for="pollQuestion">Poll Question:</label><br>
                    <input type="text" id="pollQuestion"><br><br>
                
                    <label>Poll Options:</label><br>
                    <div id="pollOptionsContainer">
                      <input type="text" class="pollOptionInput" placeholder="Option 1"><br>
                    </div>
                    <button id="addOptionButton" class="btn-sm btn-primary">Add Option</button><br><br>
                
                    <button id="createPollButton" class="btn-sm btn-success">Create</button>
                    <button id="cancelPollButton" class="btn-sm btn-danger">Cancel</button>
                  </div>
                </div>
          
                <!-- Hidden File Inputs -->
                <input type="file" id="file-input" style="display: none;">
                <input type="file" id="videoInput" style="display: none;" accept="video/*">
          
                <!-- Message Input -->
                <input type="text" id="messageInput" placeholder="Type your message..." class="form-control">
                <div id="suggestionsBox" style="display: none;"></div>
                <button type="button" id="sendMessageButton" class="btn btn-primary">
                  <i class="fa fa-paper-plane"></i>
                </button>
              </div>
            </footer>

            <!-- Floating Mini Message Box for Attach Message -->
            <div id="fileMessageContainer" class="floating-message-box" style="display: none;">
              <textarea id="fileMessageInput" placeholder="Attach a message with your file..." rows="3"></textarea>
              <div class="button-group">
                <button id="cancelMessageButton">Cancel</button>
                <button id="sendAttachedMessageButton">Send</button>
              </div>
            </div>
          </aside>

          <!-- Right Sidebar -->
          <!-- Updated Right Sidebar with Filters -->
<aside class="right-sidebar">
  <div class="user-head">
    <h3>Hub Resources</h3>
    <div class="tabs">
      <button class="tab-button active" id="filtersBtn" data-tab="filters">Filter(s)</button>
      <button class="tab-button" id="bookmarksBtn" data-tab="bookmarks">Bookmarks</button>
      <button class="tab-button" id="streamsBtn" data-tab="streams">Streams</button>
    </div>
  </div>
  
  <!-- Tab Content -->
  <div class="tab-content" id="filters" style="display:block;">
    <h4>Filters</h4>
    <div class="filter-buttons">
      <button class="filter-button active" data-filter="all">Text</button>
      <button class="filter-button" data-filter="docs">Docs</button>
      <button class="filter-button" data-filter="media">Media</button>
      <button class="filter-button" data-filter="polls">Polls</button>
    </div>
    <div class="filter-results">
      <ul class="filtered-items-list">
        <!-- Items will be populated by JavaScript -->
        <li class="no-items">Select a filter to see content</li>
      </ul>
    </div>
  </div>

  <div class="tab-content" id="bookmarks">
    <h4>Bookmarks</h4>
    <ul class="bookmarks-list">
      {% if bookmarks %}
        {% for bookmark in bookmarks %}
          <div class="bookmark-item">
            <button class="bookmark-button" onclick="openSidePanel('{{ bookmark.message }}', '{{ bookmark.question_id }}')">{{ bookmark.message }}</button>
          </div>
        {% endfor %}
      {% else %}
        <div class="no-bookmarks">
          No bookmarks available.
        </div>
      {% endif %}
    </ul>
  </div>

  <div class="tab-content" id="streams">
    <h4>Streams</h4>
    <ul class="streams-list">
      {% if streams %}
        {% for stream in streams %}
          <li>{{ stream }}</li>
        {% endfor %}
      {% else %}
        <li class="no-streams">No streams available.</li>
      {% endif %}
    </ul>
  </div>
</aside>

        </div>
      </div>
    </div>
  </section>

  <!-- Side Panel for Message Replies -->
  <div id="side-panel" class="side-panel">
    <!-- Header with Sorting Options -->
    <div class="side-panel-header">
      <div class="header-content">
        <h2 id="panel-title">Message Title</h2><br>
        <div class="reply-sort-options">
          <button class="sort-button active" data-sort="recent">Recent</button>
          <button class="sort-button" data-sort="top">Top</button>
          <button class="sort-buttons" id="summariseButton">Summarise</button>
        </div>
      </div>
      <div class="bookmark-container">
        <button id="bookmark-button" class="bookmark-button circle">
          <i class="fa fa-bookmark"></i>
        </button>
      </div>
    </div>
  
    <!-- Messages Container -->
    <div class="side-panel-messages" id="sidePanelMessages">
      <!-- Dynamic content will be loaded here -->
    </div>
  
    <!-- Input Area -->
    <div class="side-panel-input">
      <input type="text" id="sidePanelInput" placeholder="Type your reply..." class="form-control">
      <button type="button" id="sidePanelSendButton"><i class="fa fa-paper-plane"></i></button>
    </div>
  </div>


<!-- Invite Students Modal -->
<div class="modal fade" id="inviteStudentModal" tabindex="-1" aria-labelledby="inviteStudentModalLabel" aria-hidden="true">
  
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="inviteStudentModalLabel">Invite Students to {{ hub }}</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="inviteForm">
          <div class="mb-3">
            <label for="studentEmail" class="form-label">Search Student</label>
            <input type="text" class="form-control" id="studentEmail" placeholder="Enter student name or email">
            <small class="form-text text-muted">Search for students to invite to this hub</small>
          </div>
          <div class="mb-3">
            <h6>Available Students</h6>
            <div id="studentButtonsDiv" class="student-list">
              <!-- Student buttons will be populated dynamically -->
            </div>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" id="sendInviteBtn">Send Invite</button>
      </div>
    </div>
  </div>
</div>


  <!-- Enhanced Analytics Modal -->
<div class="modal fade" id="analyticsModal" tabindex="-1" aria-labelledby="analyticsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg analytics-modal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="analyticsModalLabel">Room Analytics: {{ hub }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <!-- Loading spinner -->
          <div class="spinner-container" id="analyticsSpinner">
            <div class="analytics-spinner"></div>
            <p class="mt-3 text-muted">Loading analytics data...</p>
          </div>
          
          <!-- Analytics content (hidden initially) -->
          <div id="analyticsContent" style="display: none;">
            <!-- Analytics Tabs -->
            <div class="analytics-tabs">
              <div class="analytics-tab active" data-tab="overview">Overview</div>
              <div class="analytics-tab" data-tab="engagement">User Engagement</div>
              <div class="analytics-tab" data-tab="activity">Activity Timeline</div>
              <div class="analytics-tab" data-tab="polls">Poll Results</div>
            </div>
            
            <!-- Overview Tab -->
            <div class="analytics-tab-content active" id="overview-tab">
              <div class="row mb-4">
                <div class="col-md-3">
                  <div class="analytics-stat">
                    <div class="stat-value" id="total-messages">0</div>
                    <div class="stat-label">Total Messages</div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="analytics-stat">
                    <div class="stat-value" id="total-replies">0</div>
                    <div class="stat-label">Total Replies</div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="analytics-stat">
                    <div class="stat-value" id="total-participants">0</div>
                    <div class="stat-label">Participants</div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="analytics-stat">
                    <div class="stat-value" id="total-reactions">0</div>
                    <div class="stat-label">Total Reactions</div>
                  </div>
                </div>
              </div>
              
              <div class="analytics-card">
                <div class="analytics-card-header">
                  <h5>Message Types Distribution</h5>
                </div>
                <div class="analytics-card-body">
                  <div class="chart-container">
                    <canvas id="messageTypesChart"></canvas>
                  </div>
                  <div id="message-types-legend" class="text-center mt-3"></div>
                </div>
              </div>
            </div>
            
            <!-- User Engagement Tab Content -->
            <div class="analytics-tab-content" id="engagement-tab">
              <!-- This will be populated by JavaScript -->
            </div>
            
            <!-- Activity Timeline Tab Content -->
            <div class="analytics-tab-content" id="activity-tab">
              <!-- This will be populated by JavaScript -->
            </div>
            
            <!-- Polls Tab Content -->
            <div class="analytics-tab-content" id="polls-tab">
              <!-- This will be populated by JavaScript -->
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn btn-primary" id="downloadAnalyticsBtn">
            <i class="bi bi-download"></i> Download Report
          </button>
        </div>
      </div>
    </div>
  </div>
  

 
   <!-- Manage Livestreams Modal -->
<div class="modal fade" id="manageLivestreamModal" tabindex="-1" aria-labelledby="manageLivestreamModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="manageLivestreamModalLabel">Manage Livestreams</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <!-- Livestream Management Tabs -->
        <ul class="nav nav-tabs" id="livestreamTabs" role="tablist">
          <li class="nav-item" role="presentation">
            <button class="nav-link active" id="upcoming-tab" data-bs-toggle="tab" data-bs-target="#upcoming-streams" type="button" role="tab" aria-controls="upcoming-streams" aria-selected="true">Upcoming Livestreams</button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="past-tab" data-bs-toggle="tab" data-bs-target="#past-streams" type="button" role="tab" aria-controls="past-streams" aria-selected="false">Past Livestreams</button>
          </li>
        </ul>
        
        <div class="tab-content mt-3" id="livestreamTabContent">
          <!-- Upcoming Livestreams Tab -->
          <div class="tab-pane fade show active" id="upcoming-streams" role="tabpanel" aria-labelledby="upcoming-tab">
            <div class="d-flex justify-content-end mb-3">

            </div>
            
            <div id="upcomingStreamsList" class="livestream-list">
              <!-- Upcoming livestreams will be loaded here -->
              <div class="text-center py-4" id="upcoming-loading">
                <div class="spinner-border text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
              </div>
              <div class="no-streams-message" id="no-upcoming-streams" style="display: none;">
                <p>No upcoming livestreams scheduled.</p>
              </div>
            </div>
          </div>
          
          <!-- Past Livestreams Tab -->
          <div class="tab-pane fade" id="past-streams" role="tabpanel" aria-labelledby="past-tab">
            <div id="pastStreamsList" class="livestream-list">
              <!-- Past livestreams will be loaded here -->
              <div class="text-center py-4" id="past-loading">
                <div class="spinner-border text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
              </div>
              <div class="no-streams-message" id="no-past-streams" style="display: none;">
                <p>No past livestreams available.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" id="scheduleLivestreamBtn">
          <i class="bi bi-calendar-plus"></i> Schedule Livestream
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Schedule Livestream Form Modal -->
<div class="modal fade" id="scheduleLivestreamFormModal" tabindex="-1" aria-labelledby="scheduleLivestreamFormModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="scheduleLivestreamFormModalLabel">Schedule New Livestream</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="scheduleLivestreamForm">
          <div class="mb-3">
            <label for="livestreamTitle" class="form-label">Livestream Title*</label>
            <input type="text" class="form-control" id="livestreamTitle" required>
            <div class="invalid-feedback">
              Please provide a title for the livestream.
            </div>
          </div>
          <div class="mb-3">
            <label for="livestreamDescription" class="form-label">Description (Optional)</label>
            <textarea class="form-control" id="livestreamDescription" rows="3"></textarea>
          </div>
          <div class="mb-3">
            <label for="livestreamDate" class="form-label">Date*</label>
            <input type="date" class="form-control" id="livestreamDate" required>
            <div class="invalid-feedback">
              Please select a date.
            </div>
          </div>
          <div class="mb-3">
            <label for="livestreamTime" class="form-label">Time*</label>
            <input type="time" class="form-control" id="livestreamTime" required>
            <div class="invalid-feedback">
              Please select a time.
            </div>
          </div>
          <div class="mb-3">
            <label for="livestreamDuration" class="form-label">Duration (minutes)*</label>
            <input type="number" class="form-control" id="livestreamDuration" min="15" max="240" value="60" required>
            <div class="invalid-feedback">
              Please specify a duration between 15 and 240 minutes.
            </div>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="notifyStudents" checked>
            <label class="form-check-label" for="notifyStudents">
              Notify all students about this livestream
            </label>
          </div>
        </form>
        <div class="alert alert-danger" id="scheduleLivestreamError" style="display: none;"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="createLivestreamBtn">Schedule Livestream</button>
      </div>
    </div>
  </div>
</div>



<style>
  /* Livestream Styles */
.livestream-list {
  max-height: 400px;
  overflow-y: auto;
}

.livestream-card {
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  margin-bottom: 16px;
  padding: 16px;
  position: relative;
  transition: transform 0.2s, box-shadow 0.2s;
}

.livestream-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.livestream-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

.livestream-title {
  font-size: 1.2rem;
  font-weight: 600;
  color: #333;
  margin-bottom: 5px;
}

.livestream-meta {
  color: #6c757d;
  font-size: 0.9rem;
  margin-bottom: 10px;
}

.livestream-description {
  color: #495057;
  margin-bottom: 15px;
}

.livestream-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.livestream-status {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: 500;
}

.livestream-status.upcoming {
  background-color: #e3f2fd;
  color: #0d6efd;
}

.livestream-status.live {
  background-color: #f8d7da;
  color: #dc3545;
  animation: pulse 1.5s infinite;
}

.livestream-status.past {
  background-color: #f8f9fa;
  color: #6c757d;
}

.livestream-actions {
  display: flex;
  gap: 8px;
}

.no-streams-message {
  text-align: center;
  padding: 30px;
  color: #6c757d;
  background-color: #f8f9fa;
  border-radius: 8px;
  margin: 20px 0;
}

/* Student livestream notification styles */
.livestream-notification {
  background-color: #fff3cd;
  border-left: 4px solid #ffc107;
  padding: 12px 16px;
  margin-bottom: 16px;
  border-radius: 4px;
}

.livestream-notification-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.livestream-notification-title {
  font-weight: 600;
  color: #212529;
}

.livestream-notification-close {
  background: none;
  border: none;
  font-size: 1.2rem;
  color: #6c757d;
  cursor: pointer;
}

.livestream-notification-time {
  font-weight: 500;
  color: #dc3545;
}

.livestream-count-badge {
  position: absolute;
  top: -5px;
  right: -5px;
  padding: 3px 6px;
  border-radius: 50%;
  background-color: #dc3545;
  color: white;
  font-size: 0.7rem;
  font-weight: bold;
}

/* Countdown timer styles */
.countdown-timer {
  display: inline-flex;
  margin-top: 10px;
  font-weight: 500;
}

.countdown-segment {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-right: 10px;
}

.countdown-number {
  background-color: #f8f9fa;
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 1.1rem;
  min-width: 40px;
  text-align: center;
}

.countdown-label {
  font-size: 0.7rem;
  color: #6c757d;
  margin-top: 2px;
}

@keyframes pulse {
  0% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
  100% {
    opacity: 1;
  }
}
</style>






  <!-- Hidden element to store room ID for JavaScript -->
  <div id="room-id-data" data-room-id="{{ room_id }}" style="display: none;"></div>
  <div id="teacher-name" data-teacher-name="{{ current_teachers_name|escapejs }}" style="display: none;"></div>



  
  <!-- Add JavaScript to handle analytics report download -->
  <script>
    document.getElementById('downloadAnalyticsBtn').addEventListener('click', function() {
      // Create a simple report based on the analytics data
      if (typeof analyticsData !== 'undefined') {
        // Generate report content
        let reportContent = `# Analytics Report for {{ hub }}\n`;
        reportContent += `Generated: ${new Date().toLocaleString()}\n\n`;
        
        // Add overview stats
        if (analyticsData.message_metrics) {
          reportContent += `## Overview\n`;
          reportContent += `- Total Messages: ${analyticsData.message_metrics.total_messages || 0}\n`;
          reportContent += `- Total Replies: ${analyticsData.message_metrics.total_replies || 0}\n`;
          reportContent += `- Total Participants: ${analyticsData.message_metrics.total_participants || 0}\n`;
          
          // Message types
          if (analyticsData.message_metrics.message_types) {
            reportContent += `\n### Message Types\n`;
            Object.entries(analyticsData.message_metrics.message_types).forEach(([type, count]) => {
              reportContent += `- ${type}: ${count}\n`;
            });
          }
        }
        
        // Add user engagement
        if (analyticsData.user_engagement) {
          reportContent += `\n## User Engagement\n`;
          reportContent += `- Participation Rate: ${analyticsData.user_engagement.participation_percentage?.toFixed(1) || 0}%\n`;
          
          // Top contributors
          if (analyticsData.user_engagement.top_contributors) {
            reportContent += `\n### Top Contributors\n`;
            analyticsData.user_engagement.top_contributors.forEach((contributor, index) => {
              reportContent += `${index + 1}. ${contributor.name || 'Unknown'}: ${contributor.messages || 0} messages\n`;
            });
          }
        }
        
        // Download the report as a text file
        const blob = new Blob([reportContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `analytics-report-${Date.now()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } else {
        console.log("I am here this is the error for downloading ")
        alert('Analytics data is not available. Please wait for the data to load.');
      }
    });
  </script>

  <!-- Add CSRF token -->
  <script>
    document.cookie = "csrftoken={{ csrf_token }}";
  </script>

  <!-- Vendor JS Files -->
  <script src="{% static 'vendor/bootstrap/js/bootstrap.bundle.min.js' %}"></script>
  <script src="{% static 'vendor/aos/aos.js' %}"></script>
  <script src="{% static 'vendor/purecounter/purecounter_vanilla.js' %}"></script>
  <script src="{% static 'vendor/glightbox/js/glightbox.min.js' %}"></script>
  <script src="{% static 'vendor/swiper/swiper-bundle.min.js' %}"></script>

  <!-- Main JS Files -->
  <script src="{% static 'js/main.js' %}"></script>
  <script src="{% static 'js/summarize.js' %}"></script>
  <script src="{% static 'js/invite_students.js' %}"></script> 
  <script src="{% static 'js/room-analytics.js' %}"></script> 
  <script src="{% static 'js/Teachers_livestream.js' %}"></script> 
  <script>


    
    const currentRoomId = "{{ room_id|escapejs }}";
    const currentUserName = "{{ current_teachers_name|escapejs }}";
    
    // Add CSS for toast notifications
    document.head.insertAdjacentHTML('beforeend', `
    <style>
    #toast-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 9999;
    }
    </style>
    `);
    
    
    
    
    
    
    // User's poll votes storage
    const userPollVotes = {}; // Format: { pollId: selectedOption }
    
    // Function to submit a poll vote
    function submitPollVote(messageId, roomId) {
      console.log(" I am here now i want to cast my vote")
        const form = document.getElementById(`poll-form-${messageId}`);
        const selectedOption = form.querySelector(`input[name="poll-option-${messageId}"]:checked`);
        const voteButton = document.getElementById(`poll-vote-${messageId}`);
        
        // If user has already voted for this poll
        if (userPollVotes[messageId]) {
            showToast("You've already voted in this poll", "info");
            return;
        }
        
        if (!selectedOption) {
            showToast("Please select an option", "error");
            return;
        }
        
        const selectedValue = selectedOption.value;
        
        // Disable the vote button during submission
        voteButton.disabled = true;
        voteButton.textContent = "Voting...";
        
        fetch("/poll-voting/", { 
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                "X-CSRFToken": getCookie("csrftoken"),
            },
            body: JSON.stringify({
                message_id: messageId,
                room_id: roomId,
                selected_option: selectedValue,
                username: currentUserName
            }),
        })
        .then(response => response.json())
        .then(data => {
            voteButton.disabled = false;
            voteButton.textContent = "Vote";
            
            if (data.success) {
                // Update the vote counts in the UI
                data.poll_options.forEach((option, index) => {
                    const voteCountElement = document.getElementById(`vote-count-${messageId}-${index + 1}`);
                    if (voteCountElement) {
                        voteCountElement.textContent = option.votes;
                    }
                });
                
                // Store the user's vote
                userPollVotes[messageId] = selectedValue;
                
                // Change the UI to show the user has voted
                markPollAsVoted(messageId, selectedValue);
                
                showToast("Vote submitted successfully", "success");
            } else {
                if (data.error === "already_voted") {
                    showToast("You've already voted in this poll", "info");
                    
                    // Update the UI to reflect the user's previous vote
                    if (data.user_vote) {
                        userPollVotes[messageId] = data.user_vote;
                        markPollAsVoted(messageId, data.user_vote);
                    }
                } else {
                    showToast("Failed to submit vote", "error");
                }
            }
        })
        .catch(error => {
            console.error('Error:', error);
            voteButton.disabled = false;
            voteButton.textContent = "Vote";
            showToast("An error occurred", "error");
        });
    }
    
    // Function to mark a poll as voted for this user
    function markPollAsVoted(messageId, selectedValue) {
        const form = document.getElementById(`poll-form-${messageId}`);
        const voteButton = document.getElementById(`poll-vote-${messageId}`);
        const radioButtons = form.querySelectorAll(`input[type="radio"]`);
        
        // Disable all radio buttons
        radioButtons.forEach(radio => {
            radio.disabled = true;
            
            // Highlight the user's choice
            if (radio.value === selectedValue) {
                radio.checked = true;
                radio.parentElement.classList.add('user-voted');
            }
        });
        
        // Change the vote button to show "Voted"
        voteButton.textContent = "Voted";
        voteButton.disabled = true;
        voteButton.classList.add('voted');
        
        // Add a class to the form to show it's been voted on
        form.classList.add('voted');
    }
    
    // Function to check user's poll votes when loading the page
    function checkUserPollVotes() {
        // Get all poll IDs on the page
        const pollForms = document.querySelectorAll('form[id^="poll-form-"]');
        const pollIds = Array.from(pollForms).map(form => form.dataset.messageId);
        
        if (pollIds.length === 0) return;
        
        fetch("/check-poll-votes/", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                username: currentUserName,
                poll_ids: pollIds
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success && data.votes) {
                // Update userPollVotes and UI for each poll
                Object.entries(data.votes).forEach(([pollId, voteInfo]) => {
                    userPollVotes[pollId] = voteInfo.option;
                    markPollAsVoted(pollId, voteInfo.option);
                });
            }
        })
        .catch(error => {
            console.error('Error checking poll votes:', error);
        });
    }
    
    // Add CSS for voted polls
    const pollStyles = `
    .poll-vote-button.voted {
        background-color: #4CAF50;
        cursor: default;
    }
    
    form.voted .pollOptionInput {
        opacity: 0.7;
    }
    
    li.user-voted {
        background-color: rgba(76, 175, 80, 0.1);
        border-radius: 4px;
        padding: 4px;
    }
    
    .poll-results-bar {
        height: 10px;
        background-color: #e0e0e0;
        border-radius: 5px;
        margin-top: 4px;
        position: relative;
        overflow: hidden;
    }
    
    .poll-results-fill {
        height: 100%;
        background-color: #2196F3;
        border-radius: 5px;
        transition: width 0.5s ease-in-out;
    }
    
    .poll-option-votes {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 2px;
    }
    
    .poll-option-text {
        flex-grow: 1;
        margin-right: 10px;
    }
    
    .poll-option-count {
        font-weight: bold;
        min-width: 30px;
        text-align: right;
    }
    `;
    
    // Add the styles to the head
    document.head.insertAdjacentHTML('beforeend', `<style>${pollStyles}</style>`);
    
    // Call this function when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Check user's poll votes
        checkUserPollVotes();
    });
    
    
    
    
    
    
    
        document.addEventListener('DOMContentLoaded', function () {
        // Access the roomId passed from Django context
        const roomId = "{{ room_id|escapejs }}";  // Ensure the roomId is properly passed from Django context
    
        // Set up a timeout for debouncing the input
        let debounceTimeout;
    
        // Listen for input event in the message input field
        document.getElementById('messageInput').addEventListener('input', async (event) => {
            const query = event.target.value.trim();
    
            // Log the query to check what the user is typing
            console.log("User input:", query);
    
            // Clear the previous timeout to implement debouncing
            clearTimeout(debounceTimeout);
    
            if (query.length > 0) {
                // Show the suggestion box when the user types
                document.getElementById('suggestionsBox').style.display = 'block';
    
                // Set a timeout to make the request after the user stops typing for 300ms
                debounceTimeout = setTimeout(async () => {
                    try {
                        console.log("Making request with query:", query, "and roomId:", roomId);
    
                        // Call the backend to get similar questions based on roomId and query
                        const response = await fetch(`/get_suggestions/?query=${encodeURIComponent(query)}&room_id=${encodeURIComponent(roomId)}`);
    
                        if (response.ok) {
                            const suggestions = await response.json();
                            console.log("Suggestions received:", suggestions);  // Log the suggestions received from the server
                            showSuggestions(suggestions);
                        } else {
                            console.error('Failed to fetch suggestions:', response.status);
                            document.getElementById('suggestionsBox').style.display = 'none';
                        }
                    } catch (error) {
                        console.error('Error fetching suggestions:', error);
                        document.getElementById('suggestionsBox').style.display = 'none';
                    }
                }, 300); // 300ms debounce time
            } else {
                // Hide the suggestion box when the input is empty
                document.getElementById('suggestionsBox').style.display = 'none';
            }
        });
    
        document.addEventListener('click', function(event) {
            const suggestionsBox = document.getElementById('suggestionsBox');
            const messageInput = document.getElementById('messageInput');
    
            // Check if the clicked element is inside the suggestions box or the input field
            if (!suggestionsBox.contains(event.target) && event.target !== messageInput) {
                suggestionsBox.style.display = 'none'; // Hide the box
            }
        });
    
    
        // Function to display suggestions
        function showSuggestions(suggestions) {
        const suggestionsBox = document.getElementById('suggestionsBox');
        suggestionsBox.innerHTML = ''; // Clear any old suggestions
    
        if (!suggestions || !suggestions.suggestions || suggestions.suggestions.length === 0) {
            // If there are no suggestions, show a "no results" message
            const noResult = document.createElement('div');
            noResult.textContent = 'No suggestions found';
            suggestionsBox.appendChild(noResult);
            return; // Stop the function here
        }
    
        // Loop through each suggestion and create a button
        suggestions.suggestions.forEach(suggestion => {
            const button = document.createElement('button');
            button.textContent = suggestion.question; // Use the question as the button text
            button.classList.add('suggestion-button'); // Add a class for styling
    
            // When the button is clicked, open the side panel
            button.addEventListener('click', () => {
                openSidePanel(suggestion.question, suggestion.message_id);
            });
    
            suggestionsBox.appendChild(button); // Add the button to the suggestion box
        });
    }
    });
    
    
    
    
    
    
    
    
    // Filter functionality for hub resources
// Filter functionality for hub resources
// This function runs when the document is fully loaded
document.addEventListener("DOMContentLoaded", function () {
  const tabButtons = document.querySelectorAll(".tab-button");
  const tabContents = document.querySelectorAll(".tab-content");
  const filterButtons = document.querySelectorAll(".filter-button");
  const roomId = document.getElementById("room-id-data").dataset.roomId;
  const currentStudentName = document.getElementById("room-id-data").dataset.username;
  
  // Add the pulse animation style
  addPulseStyle();
  
  // Set up tab switching
  tabButtons.forEach(button => {
    button.addEventListener("click", function () {
      const tabName = this.getAttribute("data-tab");
      sendTabClickData(tabName, roomId, currentStudentName);
      
      tabContents.forEach(content => {
        content.style.display = "none";
      });
      
      document.getElementById(tabName).style.display = "block";
      
      tabButtons.forEach(btn => btn.classList.remove("active"));
      this.classList.add("active");
      
      if (tabName === "bookmarks") {
        fetchBookmarks(roomId, currentStudentName);
      } else if (tabName === "filters") {
        // Get the active filter button
        const activeFilter = document.querySelector(".filter-button.active");
        const filterType = activeFilter ? activeFilter.getAttribute("data-filter") : "all";
        
        // Load content for the active filter (or 'all' by default)
        fetchFilteredContent(filterType);
      }
    });
  });
  
  // Set up filter buttons
  filterButtons.forEach(button => {
    button.addEventListener("click", function() {
      const filterType = this.getAttribute("data-filter");
      
      // Update active button
      filterButtons.forEach(btn => btn.classList.remove("active"));
      this.classList.add("active");
      
      // Fetch and display filtered content
      fetchFilteredContent(filterType);
    });
  });
  
  // Function to fetch filtered content from the server
  function fetchFilteredContent(filterType) {
    displayLoading();
    
    // Fetch from server with the specific filter type
    fetch(`/get-filtered-content/?room_id=${roomId}&filter_type=${filterType}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          displayFilteredContent(filterType, data.messages);
        } else {
          displayError(data.error || "Failed to load content");
        }
      })
      .catch(error => {
        console.error("Error fetching filtered content:", error);
        displayError("Network error while loading content");
      });
  }
  
  // Function to show loading state
  function displayLoading() {
    const resultsList = document.querySelector(".filtered-items-list");
    resultsList.innerHTML = "<li class='loading-items'>Loading content...</li>";
  }
  
  // Function to display error messages
  function displayError(message) {
    const resultsList = document.querySelector(".filtered-items-list");
    resultsList.innerHTML = `<li class='error-message'>${message}</li>`;
  }
  
  // Function to log tab click data
  function sendTabClickData(tabName, room_id, username) {
    fetch("/log-tab-click/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCookie("csrftoken"),
      },
      body: JSON.stringify({ tab_name: tabName, roomId: room_id, username: username })
    })
    .then(response => response.json())
    .then(data => console.log("Tab click logged:", data))
    .catch(error => console.error("Error logging tab click:", error));
  }
  
  // Function to fetch bookmarks
  function fetchBookmarks(room_id, username) {
    fetch("/log-tab-click/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCookie("csrftoken"),
      },
      body: JSON.stringify({ tab_name: "bookmarked", roomId: room_id, username: username })
    })
    .then(response => response.json())
    .then(data => {
      if (data.status === "success" && data.bookmarked_messages) {
        updateBookmarksUI(data.bookmarked_messages);
      } else {
        console.error("Error fetching bookmarks:", data.message);
      }
    })
    .catch(error => console.error("Fetch error:", error));
  }
  
  // Function to update bookmarks UI
  function updateBookmarksUI(bookmarks) {
    const bookmarksList = document.querySelector(".bookmarks-list");
    bookmarksList.innerHTML = ""; // Clear previous content
    
    if (bookmarks.length > 0) {
      bookmarks.forEach(bookmark => {
        const listItem = document.createElement("li");
        const button = document.createElement("button");
        button.textContent = bookmark.message;
        button.classList.add("bookmark-button");
        button.onclick = function() {
          navigateToMessage(bookmark.question_id, bookmark.message);
        };
        listItem.appendChild(button);
        bookmarksList.appendChild(listItem);
      });
    } else {
      bookmarksList.innerHTML = "<li>No bookmarks available.</li>";
    }
  }
  
  // Helper function to get cookies
  function getCookie(name) {
    const cookies = document.cookie.split("; ");
    for (let cookie of cookies) {
      let [key, value] = cookie.split("=");
      if (key === name) return decodeURIComponent(value);
    }
  }
  
  // Load default filter (all) on initial page load
  if (document.getElementById("filters").style.display === "block") {
    fetchFilteredContent('all');
  }
});

// Function to add pulse animation style
function addPulseStyle() {
  if (!document.querySelector('style[data-pulse-style]')) {
    const style = document.createElement('style');
    style.setAttribute('data-pulse-style', 'true');
    style.textContent = `
      @keyframes message-pulse {
        0% { 
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
          background-color: rgba(0, 123, 255, 0.1); 
        }
        70% { 
          box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
          background-color: rgba(0, 123, 255, 0.2); 
        }
        100% { 
          box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
          background-color: rgba(0, 123, 255, 0.1); 
        }
      }
      
      .message-highlight-pulse {
        animation: message-pulse 2s infinite;
      }
    `;
    document.head.appendChild(style);
  }
}

// This function will scroll to the message and open the side panel
function navigateToMessage(messageId, messageContent) {
  // Find the message in the chat
  const messageElement = document.querySelector(`.message-box[data-message-id="${messageId}"]`);
  const chatContainer = document.getElementById("chatMessages");
  
  if (messageElement) {
    // First check if the message is already visible in the viewport
    const messageRect = messageElement.getBoundingClientRect();
    const containerRect = chatContainer.getBoundingClientRect();
    
    const isVisible = (
      messageRect.top >= containerRect.top &&
      messageRect.bottom <= containerRect.bottom
    );
    
    if (!isVisible) {
      // Determine if we need to scroll up or down
      if (messageRect.top < containerRect.top) {
        // Message is above viewport, scroll up
        console.log("Scrolling up to find message");
      } else {
        // Message is below viewport, scroll down
        console.log("Scrolling down to find message");
      }
      
      // Perform the scroll with smooth behavior
      messageElement.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'center' 
      });
    }
    
    // Add a visual pulse effect to make the message stand out
    messageElement.classList.add('message-highlight-pulse');
    
    // Apply highlight styling
    messageElement.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
    messageElement.style.boxShadow = '0 0 15px rgba(0, 123, 255, 0.7)';
    
    // Remove the highlight and pulse after a few seconds
    setTimeout(() => {
      messageElement.style.backgroundColor = '';
      messageElement.style.boxShadow = '';
      messageElement.classList.remove('message-highlight-pulse');
    }, 3000);
    
    // Open the side panel with this message
    openSidePanel(messageContent, messageId);
  } else {
    console.error(`Message with ID ${messageId} not found in the chat`);
    
    // Try to fetch messages in case they're not loaded yet
    alert("That message could not be found in the current view. Opening in side panel instead.");
    
    // Still try to open the side panel even if we can't find the message
    openSidePanel(messageContent, messageId);
  }
}

// Update the displayFilteredContent function to use the improved navigation
function displayFilteredContent(filterType, messages) {
  const resultsList = document.querySelector(".filtered-items-list");
  resultsList.innerHTML = "";
  
  // Display filtered items
  if (messages.length === 0) {
    resultsList.innerHTML = `<li class="no-items">No ${filterType === 'all' ? 'content' : filterType} found</li>`;
    return;
  }
  
  messages.forEach(item => {
    const listItem = document.createElement("li");
    listItem.className = "filtered-item";
    
    // Create a button to open the message in the side panel
    const button = document.createElement("button");
    button.className = "filter-item-button";
    
    // Add the full content as a title attribute for tooltip hover effect
    if (item.content) {
      button.title = item.content;
    }
    
    // Set click handler to navigate to the message in chat
    button.onclick = function() {
      // Add a small loading indicator on the button
      const originalContent = button.innerHTML;
      button.innerHTML = '<i class="fa fa-circle-o-notch fa-spin"></i> Finding...';
      
      // Use setTimeout to allow the UI to update before navigation
      setTimeout(() => {
        navigateToMessage(item.message_id, item.content);
        // Restore the button's original content
        button.innerHTML = originalContent;
      }, 200);
    };
    
    // Create appropriate content preview based on type
    if (item.is_poll) {
      button.innerHTML = `<i class="fa fa-bar-chart"></i> <span>${item.content || "Poll"}</span>`;
      button.classList.add("poll-item");
    } else if (item.file_url) {
      button.innerHTML = `<i class="fa fa-file"></i> <span>${item.content || "File"}</span>`;
      button.classList.add("doc-item");
    } else if (item.image_url) {
      button.innerHTML = `<i class="fa fa-image"></i> <span>${item.content || "Image"}</span>`;
      button.classList.add("image-item");
    } else if (item.video_url) {
      button.innerHTML = `<i class="fa fa-video-camera"></i> <span>${item.content || "Video"}</span>`;
      button.classList.add("video-item");
    } else {
      button.innerHTML = `<i class="fa fa-comment"></i> <span>${item.content || "Message"}</span>`;
    }
    
    listItem.appendChild(button);
    resultsList.appendChild(listItem);
  });
  
  // Add styles for the filter items
  const style = document.createElement('style');
  style.textContent = `
    .filtered-item {
      margin-bottom: 8px;
    }
    
    .filter-item-button {
      width: 100%;
      text-align: left;
      padding: 8px 12px;
      background-color: #f5f5f5;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .filter-item-button:hover {
      background-color: #e9f0ff;
      border-color: #c0d6ff;
    }
    
    .filter-item-button i {
      margin-right: 8px;
      font-size: 14px;
    }
    
    .filter-item-button.poll-item i {
      color: #dc3545;
    }
    
    .filter-item-button.doc-item i {
      color: #007bff;
    }
    
    .filter-item-button.image-item i {
      color: #28a745;
    }
    
    .filter-item-button.video-item i {
      color: #fd7e14;
    }
    
    .filter-item-button span {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  `;
  
  // Only add the style once
  if (!document.querySelector('style[data-filter-styles]')) {
    style.setAttribute('data-filter-styles', 'true');
    document.head.appendChild(style);
  }
}
    
    
    
    
    
    
        
    const userVotes = {}; // To track user votes: {replyId: "up"|"down"|null}
    
    function attachVoteHandlers() {
        // Add event listeners to all vote buttons
        document.querySelectorAll(".vote-button").forEach(button => {
            button.addEventListener("click", function() {
                const replyId = this.dataset.replyId;
                const voteType = this.classList.contains("upvote") ? "up" : "down";
                handleVote(replyId, voteType, this);
            });
        });
    }
    
    function handleVote(replyId, voteType, buttonElement) {
        // Get the opposing button (if upvote was clicked, get the downvote button and vice versa)
        const container = buttonElement.closest('.reply-footer');
        const upvoteButton = container.querySelector('.upvote');
        const downvoteButton = container.querySelector('.downvote');
        const voteCountElement = container.querySelector('.vote-count');
        const currentVoteCount = parseInt(voteCountElement.textContent.trim(), 10) || 0;
        
        // Get current vote state for this reply
        const currentVote = userVotes[replyId];
        
        // User is clicking the same button they already voted on - remove vote
        if (currentVote === voteType) {
            // Remove vote styling
            buttonElement.classList.remove('voted');
            
            // Send request to remove vote
            sendVoteRequest(replyId, 'remove', currentVoteCount, voteCountElement);
            
            // Update tracking
            userVotes[replyId] = null;
            
            showToast(`Vote removed`, "info");
            return;
        }
        
        // User is changing vote from one type to another
        if (currentVote && currentVote !== voteType) {
            // Remove styling from previous vote
            if (currentVote === 'up') {
                upvoteButton.classList.remove('voted');
            } else {
                downvoteButton.classList.remove('voted');
            }
            
            // Add styling to new vote
            buttonElement.classList.add('voted');
            
            // Send request to change vote
            sendVoteRequest(replyId, 'change', currentVoteCount, voteCountElement, voteType, currentVote);
            
            // Update tracking
            userVotes[replyId] = voteType;
            
            showToast(`Vote changed to ${voteType}vote`, "info");
            return;
        }
        
        // User is voting for the first time
        buttonElement.classList.add('voted');
        
        // Send request to add vote
        sendVoteRequest(replyId, 'add', currentVoteCount, voteCountElement, voteType);
        
        // Update tracking
        userVotes[replyId] = voteType;
        
        showToast(`${voteType === 'up' ? 'Upvoted' : 'Downvoted'} reply`, "success");
    }
    
    function sendVoteRequest(replyId, action, currentCount, countElement, newVote = null, oldVote = null) {
        // Immediately update the UI optimistically
        let newCount = currentCount;
        
        if (action === 'add') {
            newCount += newVote === 'up' ? 1 : -1;
        } else if (action === 'remove') {
            newCount += userVotes[replyId] === 'up' ? -1 : 1;
        } else if (action === 'change') {
            // If changing from up to down, that's -2 (remove up, add down)
            // If changing from down to up, that's +2 (remove down, add up)
            newCount += newVote === 'up' ? 2 : -2;
        }
        
        // Update the UI immediately
        countElement.textContent = newCount;
        
        // Make the API request
        fetch('/vote-reply/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                reply_id: replyId,
                vote_type: newVote,
                username: currentUserName,
                action: action,
                old_vote: oldVote
            })
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                // If there was an error, revert the UI
                countElement.textContent = currentCount;
                showToast(data.error || "Error updating vote", "error");
                
                // Revert the vote tracking
                if (action === 'add') {
                    userVotes[replyId] = null;
                } else if (action === 'remove') {
                    userVotes[replyId] = oldVote;
                } else if (action === 'change') {
                    userVotes[replyId] = oldVote;
                }
                
                // Revert the UI classes
                const container = countElement.closest('.reply-footer');
                const upvoteButton = container.querySelector('.upvote');
                const downvoteButton = container.querySelector('.downvote');
                
                upvoteButton.classList.remove('voted');
                downvoteButton.classList.remove('voted');
                
                if (userVotes[replyId] === 'up') {
                    upvoteButton.classList.add('voted');
                } else if (userVotes[replyId] === 'down') {
                    downvoteButton.classList.add('voted');
                }
            } else {
                // Update the count with the actual value from the server
                if (data.newCount !== undefined) {
                    countElement.textContent = data.newCount;
                }
            }
        })
        .catch(error => {
            console.error('Error updating vote:', error);
            showToast("Network error while voting", "error");
            
            // Revert the UI
            countElement.textContent = currentCount;
        });
    }
    
    // Function to get the current vote for a reply
    function fetchUserVotes() {
        // Get all reply IDs currently visible in the side panel
        const replyIds = [];
        document.querySelectorAll('.reply-footer .vote-button').forEach(button => {
            const replyId = button.dataset.replyId;
            if (replyId && !replyIds.includes(replyId)) {
                replyIds.push(replyId);
            }
        });
        
        if (replyIds.length === 0) return;
        
        // Fetch vote status for these replies
        fetch('/get-user-votes/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                username: currentUserName,
                reply_ids: replyIds
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.votes) {
                // Update userVotes and UI
                Object.entries(data.votes).forEach(([replyId, voteType]) => {
                    userVotes[replyId] = voteType;
                    
                    // Update UI to show voted state
                    const container = document.querySelector(`.vote-button[data-reply-id="${replyId}"]`).closest('.reply-footer');
                    const upvoteButton = container.querySelector('.upvote');
                    const downvoteButton = container.querySelector('.downvote');
                    
                    upvoteButton.classList.remove('voted');
                    downvoteButton.classList.remove('voted');
                    
                    if (voteType === 'up') {
                        upvoteButton.classList.add('voted');
                    } else if (voteType === 'down') {
                        downvoteButton.classList.add('voted');
                    }
                });
            }
        })
        .catch(error => {
            console.error('Error fetching vote status:', error);
        });
    }
    
    // CSS for voted buttons
    const voteStyles = `
    .vote-button.voted {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
    }
    .vote-button.upvote.voted i {
        color: white;
    }
    .vote-button.downvote.voted i {
        color: white;
    }
    `;
    
    // Add the styles to the head
    document.head.insertAdjacentHTML('beforeend', `<style>${voteStyles}</style>`);
    
    
    
    
    document.addEventListener("DOMContentLoaded", function () {
        const attachFileButton = document.getElementById("attachFileButton");
        const uploadMenu = document.getElementById("upload-menu");
        const uploadFileButton = document.getElementById("upload-file");
        const uploadVideoButton = document.getElementById("upload-video");
        const fileInput = document.getElementById("file-input");
        const videoInput = document.getElementById("videoInput");  // Video input for videos
        const messageInput = document.getElementById("messageInput"); // Input for the message
        const fileMessageInput = document.getElementById("fileMessageInput"); // Input for the file message
        const fileMessageContainer = document.getElementById("fileMessageContainer"); // Floating message box container
        let selectedFile = null;
        let selectedVideo = null;
        const roomId = "{{ room_id|escapejs }}";
        const currentTeacherName = "{{ current_teachers_name|escapejs }}";
    
        const uploadPollButton = document.getElementById("upload-poll");
        const pollGui = document.getElementById("poll-gui");
        const createPollButton = document.getElementById("createPollButton");
        const cancelPollButton = document.getElementById("cancelPollButton");
        const pollQuestionInput = document.getElementById("pollQuestion");
        const pollOptionsContainer = document.getElementById("pollOptionsContainer");
        const addOptionButton = document.getElementById("addOptionButton");
    
        // Show Poll GUI on "Create Poll" Click
        uploadPollButton.addEventListener("click", function () {
            pollGui.style.display = "block";
            uploadMenu.style.display = "none"; // Hide the upload menu
        });
    
        // Hide Poll GUI on "Cancel" Click
        cancelPollButton.addEventListener("click", function () {
            pollGui.style.display = "none";
            pollQuestionInput.value = ""; // Clear the question
            pollOptionsContainer.innerHTML = '<input type="text" class="pollOptionInput" placeholder="Option 1"><br>'; // Reset options
        });
    
        addOptionButton.addEventListener("click", function () {
            const optionInputs = pollOptionsContainer.querySelectorAll(".pollOptionInput");
            const nextOptionNumber = optionInputs.length + 1;
            const newOptionInput = document.createElement("input");
            newOptionInput.type = "text";
            newOptionInput.className = "pollOptionInput";
            newOptionInput.placeholder = `Option ${nextOptionNumber}`;
    
            pollOptionsContainer.appendChild(newOptionInput);
            pollOptionsContainer.appendChild(document.createElement("br"));
        });
    
        // Send Poll Message on "Create" Click
        createPollButton.addEventListener("click", function () {
            const pollQuestion = pollQuestionInput.value.trim();
            const optionInputs = pollOptionsContainer.querySelectorAll(".pollOptionInput");
            const options = Array.from(optionInputs).map(input => input.value.trim()).filter(value => value); // Get all options that are not empty.
    
            if (pollQuestion && options.length > 1) { // Ensure there's a question and at least two options
                const message = {
                    file: "Poll docs",
                    message: pollQuestion,
                    role: "teacher",
                    room_url: roomId,
                    sender: currentTeacherName,
                    created_at: new Date().toISOString(),
                    is_poll: true,
                    poll_options: options // Added poll_options as a list
                };
    
                console.log("Poll message being sent:", message);
    
                // Send the poll message via WebSocket
                window.socket.send(JSON.stringify(message));
    
                pollGui.style.display = "none";
                pollQuestionInput.value = "";
                pollOptionsContainer.innerHTML = '<input type="text" class="pollOptionInput" placeholder="Option 1"><br>'; // Reset options
            } else {
                alert("Please enter a question and at least two options for the poll.");
            }
        });
    
        // Toggle Upload Menu on "+" Click
        attachFileButton.addEventListener("click", function () {
            uploadMenu.style.display = uploadMenu.style.display === "none" ? "block" : "none";
        });
    
        // Close menu if clicking outside
        document.addEventListener("click", function (event) {
            if (!attachFileButton.contains(event.target) && !uploadMenu.contains(event.target)) {
                uploadMenu.style.display = "none";
            }
        });
    
        // Open File Picker on "Share File" Click
        uploadFileButton.addEventListener("click", function () {
            fileInput.click(); // Opens file picker
            uploadMenu.style.display = "none"; // Hide menu after clicking
        });
    
        fileInput.addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (!file) return;
    
        console.log("Selected file:", file);
    
        let isImage = file.type.startsWith("image/");
        let isVideo = file.type.startsWith("video/");
        let isOtherFile = !isImage && !isVideo;
    
        // Show the message input field after file selection
        fileMessageContainer.style.display = "inline-block";
    
        const reader = new FileReader();
    
        reader.onload = function (e) {
            const fileData = e.target.result.split(",")[1]; // Base64 data
    
            document.getElementById("sendAttachedMessageButton").addEventListener("click", function () {
                const messageText = fileMessageInput.value.trim() || (isImage ? "My image" : "My file");
    
                const message = {
                    file: fileData,
                    message: messageText,
                    file_name: file.name,
                    file_type: file.type,
                    role: "teacher",
                    room_url: roomId,
                    sender: currentTeacherName,
                    created_at: new Date().toISOString(),
                    is_file: true,
                    is_image: isImage,
                    is_video: isVideo,
                };
    
                console.log("Message being sent:", message);
    
                // Send the message via WebSocket
                window.socket.send(JSON.stringify(message));
    
                // Clear inputs
                fileMessageInput.value = "";
                fileMessageContainer.style.display = "none";
    
                console.log("Message sent!");
            });
        };
    
        reader.readAsDataURL(file); // Convert file to base64
    });
    
    
        // Handle Video Upload Click
        uploadVideoButton.addEventListener("click", function () {
            videoInput.click(); // Open the file picker for video files
            uploadMenu.style.display = "none"; // Hide the upload menu
        });
    
        videoInput.addEventListener("change", function (event) {
            const video = event.target.files[0]; // Get the selected video file
            if (!video) return; // Exit if no video is selected
    
            console.log("Selected video:", video);
    
            const videoType = video.type; // Get MIME type of the video
    
            // Check if it's a valid video file
            if (!videoType.startsWith("video/")) {
                console.log("This is not a valid video file.");
                alert("Please select a valid video file.");
                return;
            }
    
            // Show the message input field after video selection
            fileMessageContainer.style.display = "inline-block";
    
            const reader = new FileReader();
    
            reader.onload = function (e) {
                const videoData = e.target.result.split(",")[1]; // Extract base64 data
    
                document.getElementById("sendAttachedMessageButton").addEventListener("click", function () {
                    const messageText = fileMessageInput.value.trim() || "My video"; // Default to "My video" if no message
    
                    const message = {
                        file: videoData,
                        message: messageText, // Attached message
                        file_name: video.name,
                        file_type: video.type,
                        role: "teacher",
                        room_url: roomId,
                        sender: currentTeacherName,
                        created_at: new Date().toISOString(),
                        is_file: true,
                        is_video: true, // Flag indicating it's a video
                    };
    
                    console.log(message)
    
                    // Send the video message via WebSocket
                    window.socket.send(JSON.stringify(message));
    
                    // Clear the input after sending
                    fileMessageInput.value = "";
                    fileMessageContainer.style.display = "none"; // Hide the message input
                });
            };
    
            reader.readAsDataURL(video); // Read as DataURL (base64)
        });
    
        // Cancel message input when cancel button is clicked
        document.getElementById("cancelMessageButton").addEventListener("click", function () {
            fileMessageInput.value = "";
            fileMessageContainer.style.display = "none"; // Hide the message input
        });
    
    });
        
        
        
        document.addEventListener("DOMContentLoaded", function () {
            if (window.socketInitialized) {
                console.warn("WebSocket script already initialized. Exiting...");
                return;
            }
            window.socketInitialized = true;
        
            const roomId = "{{ room_id|escapejs }}";
            const currentUserName = "{{ current_teachers_name|escapejs }}";
            const userRole = "teacher";
        
            if (!roomId || !currentUserName || !userRole) {
                console.error("Missing required variables.");
                return;
            }
        
            const socketURL = `ws://${window.location.host}/ws/${userRole}s-dashboard/hub-room/${roomId}/`;
            console.log("Establishing socket connection to:", socketURL);
        
            if (!window.socket || window.socket.readyState !== WebSocket.OPEN) {
                window.socket = new WebSocket(socketURL);
            } else {
                console.log("WebSocket already open.");
                return;
            }
        
    function createMessageElement(sender, message, createdAt, role, messageId, imageUrl, fileUrl, videoUrl, pollOptions, roomUrl) {
        const newMessage = document.createElement("div");
        newMessage.className = "message-box";
        newMessage.dataset.message = message;
        newMessage.dataset.messageId = messageId;
    
        // Set appropriate class based on sender
        if (sender === currentUserName) {
            newMessage.classList.add(role === "teacher" ? "current-teacher-message" : "current-user-message");
        } else if (role === "teacher") {
            newMessage.classList.add("teacher-message");
        } else {
            newMessage.classList.add("other-user-message");
        }
    
        // Create sender span
        const senderSpan = document.createElement("span");
        senderSpan.className = "message-sender";
        senderSpan.textContent = sender === currentUserName ? "Me" : sender;
        newMessage.appendChild(senderSpan);
    
        // Handle image if present
        if (imageUrl) {
            const imgLink = document.createElement("a");
            imgLink.href = imageUrl;
            imgLink.target = "_blank";
            imgLink.className = "message-image";
    
            const imgElement = document.createElement("img");
            imgElement.src = imageUrl;
            imgElement.style.maxWidth = "400px";
            imgElement.style.height = "200px";
    
            imgLink.appendChild(imgElement);
            newMessage.appendChild(imgLink);
        }
    
        // Handle file if present
        if (fileUrl) {
            const fileDiv = document.createElement("div");
            fileDiv.className = "message-file";
    
            const fileLink = document.createElement("a");
            fileLink.href = fileUrl;
            fileLink.target = "_blank";
    
            const fileIcon = document.createElement("img");
            fileIcon.src = "/static/images/files.png";
            fileIcon.alt = "File";
            fileIcon.style.width = "100px";
            fileIcon.style.height = "100px";
    
            fileLink.appendChild(fileIcon);
            fileDiv.appendChild(fileLink);
            
            if (message && message !== "my file") {
                const messageText = document.createElement("span");
                messageText.textContent = message;
                fileDiv.appendChild(messageText);
            }
            
            newMessage.appendChild(fileDiv);
        }
    
        // Handle video if present
        else if (videoUrl) {
            const videoDiv = document.createElement("div");
            videoDiv.className = "message-video";
    
            const videoElement = document.createElement("video");
            videoElement.src = videoUrl;
            videoElement.controls = true;
            videoElement.style.maxWidth = "200px";
            videoElement.style.maxHeight = "200px";
    
            videoDiv.appendChild(videoElement);
            newMessage.appendChild(videoDiv);
        }
    
        // Handle poll if present
        else if (pollOptions) {
        // Use our enhanced poll display function
        const pollContainer = createPollElement(message, messageId, pollOptions, roomUrl);
        newMessage.appendChild(pollContainer);
    }
        else {
            // Plain text message
            const contentSpan = document.createElement("div");
            contentSpan.className = "message-text";
            contentSpan.textContent = message;
            newMessage.appendChild(contentSpan);
            
            // Add the top reply section for non-poll messages
            const topReplyDiv = document.createElement("div");
            topReplyDiv.className = "top-reply no-reply";
            
            const emText = document.createElement("em");
            emText.textContent = "No replies yet.";
            
            topReplyDiv.appendChild(emText);
            newMessage.appendChild(topReplyDiv);
        }
    
        // Add timestamp
        const timeSpan = document.createElement("span");
        timeSpan.className = "message-time";
        timeSpan.textContent = typeof createdAt === 'string' ? createdAt : 
                              (createdAt instanceof Date ? createdAt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 
                              new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
        newMessage.appendChild(timeSpan);
    
        // Add click event to open side panel for non-poll messages
        if (!pollOptions) {
            newMessage.addEventListener("click", function() {
                openSidePanel(message, messageId);
            });
        }
    
        return newMessage;
    }
    // Enhanced function to create poll UI with percentages and progress bars
    function createPollElement(message, messageId, pollOptions, roomUrl) {
        const pollContainer = document.createElement("div");
        pollContainer.classList.add("message-poll");
    
        const question = document.createElement("strong");
        question.textContent = message;
        pollContainer.appendChild(question);
    
        const form = document.createElement("form");
        form.id = `poll-form-${messageId}`;
        form.dataset.messageId = messageId;
        form.dataset.roomId = roomUrl;
    
        const optionsList = document.createElement("ul");
        optionsList.style.listStyle = "none";
        optionsList.style.padding = "0";
        optionsList.style.margin = "10px 0";
    
        // Calculate total votes for percentages
        let totalVotes = 0;
        pollOptions.forEach(option => {
            totalVotes += option.votes || 0;
        });
    
        pollOptions.forEach((option, index) => {
            const optionText = option.option;
            const votes = option.votes || 0;
            const percentage = totalVotes > 0 ? Math.round((votes / totalVotes) * 100) : 0;
    
            const optionItem = document.createElement("li");
            optionItem.style.margin = "8px 0";
            optionItem.style.padding = "5px";
    
            // Radio button for voting
            const radioContainer = document.createElement("div");
            radioContainer.style.display = "flex";
            radioContainer.style.alignItems = "center";
            radioContainer.style.marginBottom = "5px";
    
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.id = `option-${messageId}-${index + 1}`;
            radio.name = `poll-option-${messageId}`;
            radio.value = optionText;
            radio.style.marginRight = "8px";
    
            const label = document.createElement("label");
            label.htmlFor = `option-${messageId}-${index + 1}`;
            label.textContent = optionText;
            label.style.margin = "0";
            label.style.fontSize = "14px";
            label.style.cursor = "pointer";
    
            radioContainer.appendChild(radio);
            radioContainer.appendChild(label);
            optionItem.appendChild(radioContainer);
    
            // Results display
            const resultsContainer = document.createElement("div");
            
            // Option text and vote count
            const optionInfoDiv = document.createElement("div");
            optionInfoDiv.className = "poll-option-votes";
            
            const optionTextSpan = document.createElement("span");
            optionTextSpan.className = "poll-option-text";
            optionTextSpan.textContent = `${percentage}%`;
            
            const voteCountSpan = document.createElement("span");
            voteCountSpan.className = "poll-option-count";
            voteCountSpan.id = `vote-count-${messageId}-${index + 1}`;
            voteCountSpan.textContent = votes;
            
            optionInfoDiv.appendChild(optionTextSpan);
            optionInfoDiv.appendChild(voteCountSpan);
            resultsContainer.appendChild(optionInfoDiv);
            
            // Progress bar
            const progressBar = document.createElement("div");
            progressBar.className = "poll-results-bar";
            
            const progressFill = document.createElement("div");
            progressFill.className = "poll-results-fill";
            progressFill.style.width = `${percentage}%`;
            
            progressBar.appendChild(progressFill);
            resultsContainer.appendChild(progressBar);
            
            optionItem.appendChild(resultsContainer);
            optionsList.appendChild(optionItem);
        });
    
        form.appendChild(optionsList);
    
        const voteButton = document.createElement("button");
        voteButton.type = "button";
        voteButton.classList.add("poll-vote-button");
        voteButton.id = `poll-vote-${messageId}`;
        voteButton.textContent = "Vote";
        voteButton.style.marginTop = "10px";
        voteButton.onclick = function() {
            submitPollVote(messageId, roomUrl);
        };
    
        form.appendChild(voteButton);
        pollContainer.appendChild(form);
        
        return pollContainer;
    }
    
    socket.onmessage = function (event) {
        try {
            const data = JSON.parse(event.data);
            const messageData = data.message;
    
            if (data.is_reply) {
                return;
            } else {
                if (messageData.question_id) {
                    return;
                } else {
                    const chatMessages = document.getElementById("chatMessages");
                    
                    // Format the timestamp
                    const formattedTime = new Date(messageData.created_at).toLocaleTimeString([], { 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        hour12: false 
                    });
                    
                    // Create the message element using our improved function
                    const newMessage = createMessageElement(
                        messageData.sender,
                        messageData.message,
                        formattedTime,
                        messageData.role || "teacher",
                        messageData.message_id,
                        messageData.image_url,
                        messageData.file_url,
                        messageData.video_url,
                        messageData.is_poll ? messageData.poll_options : null,
                        messageData.room_url || currentRoomId
                    );
                    
                    chatMessages.appendChild(newMessage);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }
        } catch (error) {
            console.error(" Error handling message for teacher:", error);
        }
    };
       
        
        
        
            socket.onerror = function (error) {
                console.error("WebSocket error:", error);
            };
        
            socket.onclose = function (event) {
                console.log("WebSocket closed:", event);
            };
        
            // Send messages via WebSocket
            const sendMessageButton = document.getElementById("sendMessageButton");
            const messageInput = document.getElementById("messageInput");
        
            if (sendMessageButton && messageInput) {
                sendMessageButton.addEventListener("click", function () {
                    const messageText = messageInput.value.trim();
        
                    if (messageText) {
                        socket.send(JSON.stringify({
                            message: messageText,
                            role: userRole,
                            room_url: roomId,
                            sender: currentUserName,
                            created_at: new Date().toISOString()
                        }));
        
                        // Clear the input field after sending the message
                        messageInput.value = "";
                    } else {
                        alert("Please enter a message before sending.");
                    }
                });
            }
        
            const chatMessages = document.getElementById("chatMessages");
            if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            } else {
                console.error("Chat messages container not found.");
            }
        });
        
        
        
        
        
        
        
        let currentMessageId = null;
        
        // Toggle the side panel
        function openSidePanel(messageContent, messageId) {
    const sidePanel = document.getElementById('side-panel');
    const panelTitle = document.getElementById('panel-title');
    const chatSection = document.querySelector('.chat-section');
    const rightSidebar = document.querySelector('.right-sidebar');
    
    // Current sort method - initialized to 'recent' by default
    let currentSortMethod = 'recent';

    if (sidePanel.classList.contains('open')) {
        // Close the side panel
        sidePanel.classList.remove('open');
        chatSection.style.marginLeft = '0';
        rightSidebar.style.marginLeft = '0';

        // Reset the URL to remove messageId
        const newUrl = `/teachers-dashboard/hub-room/${currentRoomId}/`;
        window.history.pushState({ path: newUrl }, "", newUrl);

        // Reset the global messageId
        currentMessageId = null;
    } else {
        // Open the side panel
        
        // Set the title text with ellipsis handled by CSS
        panelTitle.textContent = messageContent;
        
        // Also set the title attribute for showing the full text on hover
        panelTitle.title = messageContent;
        
        sidePanel.classList.add('open');
        chatSection.style.marginLeft = '250px';
        rightSidebar.style.marginLeft = 'none';

        // Store the messageId in the global variable
        currentMessageId = messageId;

        // Load replies with the default sort method (recent)
        loadReplies(messageId, currentSortMethod);
        
        // Ensure sort buttons show the correct active state
        updateSortButtonState(currentSortMethod);

        // Check bookmark status and add listeners
        addBookmarkButtonListener();
    }
    
    // Function to load replies with the given sort method
    function loadReplies(messageId, sortMethod) {
        // Construct the URL with the sort parameter
        const newUrl = `/teachers-dashboard/hub-room/${currentRoomId}/${messageId}/?sort=${sortMethod}`;
        
        // Update browser URL without the query parameter
        const displayUrl = `/teachers-dashboard/hub-room/${currentRoomId}/${messageId}/`;
        window.history.pushState({ path: displayUrl }, "", displayUrl);

        // Show loading indicator
        const messagesArea = document.getElementById('sidePanelMessages');
        if (messagesArea) {
            messagesArea.innerHTML = '<div class="loading-replies">Loading replies...</div>';
        }

        // Fetch replies from the server with the sort parameter
        fetch(newUrl, {
            method: "GET",
            headers: {
                "X-Requested-With": "XMLHttpRequest"
            }
        })
        .then(response => response.json())
        .then(data => {
            console.log("Received messages:", data);
            if (messagesArea) {
                messagesArea.innerHTML = '';  // Clear existing messages
            }

            if (data.length === 0) {
                messagesArea.innerHTML = '<div class="no-replies">No replies yet. Be the first to reply!</div>';
                return;
            }

            // Iterate through the messages and append them to the side panel
            data.forEach(message => {
                const messageElement = document.createElement('div');
                messageElement.classList.add('side-panel-message');

                // Update content based on new design
                messageElement.innerHTML = `
                    <div class="reply">
                    <div class="reply-header">
                        <span class="reply-info">${message.sender}</span>
                        <span class="reply-role">(${message.role})</span>
                    </div>
                    <p class="reply-content">${message.reply_content}</p>
                    
                    <div class="reply-footer">
                        <button class="vote-button upvote" data-reply-id="${message.reply_id}">
                            <i class="fa fa-arrow-up"></i>
                        </button>
                        <span class="vote-count" id="vote-count-${message.reply_id}">
                            ${message.upvotes - message.downvotes}
                        </span>
                        <button class="vote-button downvote" data-reply-id="${message.reply_id}">
                            <i class="fa fa-arrow-down"></i>
                        </button>
                    </div>
                    </div>
                `;
                messagesArea.appendChild(messageElement);
            });

            // After appending all messages, attach vote handlers and fetch vote status
            attachVoteHandlers();
            fetchUserVotes();
        })
        .catch(error => {
            console.error("Error fetching message:", error);
            if (messagesArea) {
                messagesArea.innerHTML = '<div class="error-message">Error loading replies. Please try again.</div>';
            }
        });
    }

    // Setup sort button event listeners if side panel is opening
    if (!sidePanel.classList.contains('open')) {
        // Add listeners to sort buttons if not already added
        const sortButtons = document.querySelectorAll('.sort-button');
        sortButtons.forEach(button => {
            // Remove existing listeners to prevent duplicates
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            // Add new listener
            newButton.addEventListener('click', function() {
                const sortMethod = this.getAttribute('data-sort');
                
                // Skip if already using this sort method
                if (sortMethod === currentSortMethod) return;
                
                // Update current sort method
                currentSortMethod = sortMethod;
                
                // Update active button state
                updateSortButtonState(sortMethod);
                
                // Reload replies with new sort method
                loadReplies(currentMessageId, currentSortMethod);
            });
        });
    }
    
    // Function to update the active state of sort buttons
    function updateSortButtonState(activeMethod) {
        const sortButtons = document.querySelectorAll('.sort-button');
        sortButtons.forEach(button => {
            if (button.getAttribute('data-sort') === activeMethod) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
    }
}
    
    function showToast(message, type) {
        // Remove any existing toast
        const existingToast = document.getElementById('toast-notification');
        if (existingToast) {
            existingToast.remove();
        }
        
        // Create toast container if it doesn't exist
        let toastContainer = document.getElementById('toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.id = 'toast-container';
            toastContainer.style.position = 'fixed';
            toastContainer.style.bottom = '20px';
            toastContainer.style.right = '20px';
            toastContainer.style.zIndex = '9999';
            document.body.appendChild(toastContainer);
        }
        
        // Create toast
        const toast = document.createElement('div');
        toast.id = 'toast-notification';
        toast.style.backgroundColor = type === 'error' ? '#f44336' : 
                                      type === 'success' ? '#4CAF50' : 
                                      type === 'info' ? '#2196F3' : '#333';
        toast.style.color = 'white';
        toast.style.padding = '16px';
        toast.style.borderRadius = '4px';
        toast.style.marginTop = '10px';
        toast.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        toast.style.minWidth = '250px';
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        toast.textContent = message;
        
        // Add toast to container
        toastContainer.appendChild(toast);
        
        // Fade in
        setTimeout(() => {
            toast.style.opacity = '1';
        }, 10);
        
        // Fade out after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }
    
    
        function addBookmarkButtonListener() {
        const bookmarkButton = document.getElementById('bookmark-button');
    
        if (bookmarkButton) {
            // First, check if the bookmark status and update button UI accordingly
            checkBookmarkStatus();
            
            // Remove any existing event listener to prevent duplicates
            bookmarkButton.removeEventListener('click', handleBookmarkClick);
            
            // Add the event listener
            bookmarkButton.addEventListener('click', handleBookmarkClick);
        } else {
            console.error("Bookmark button not found");
        }
    }
    
    // Function to check if a question is already bookmarked
    function checkBookmarkStatus() {
        const bookmarkButton = document.getElementById('bookmark-button');
        const username = currentUserName; // Make sure this variable is defined in your context
        const questionId = currentMessageId;
        const roomId = currentRoomId; // Make sure this variable is defined in your context
        
        if (!questionId) return;
        
        fetch("/check-bookmark-status/", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ username, questionId, roomId })
        })
        .then(response => response.json())
        .then(data => {
            if (data.is_bookmarked) {
                bookmarkButton.classList.add('bookmarked');
            } else {
                bookmarkButton.classList.remove('bookmarked');
            }
        })
        .catch(error => {
            console.error('Error checking bookmark status:', error);
        });
    }
    
    // Event handler for bookmark button clicks
    function handleBookmarkClick() {
        const username = currentUserName; // Make sure this variable is defined
        const questionId = currentMessageId;
        const roomId = currentRoomId; // Make sure this variable is defined
        const button = this;
        
        if (!questionId) {
            showToast("Error: Cannot identify the question to bookmark", "error");
            return;
        }
        
        button.disabled = true; // Prevent multiple clicks
        
        if (button.classList.contains('bookmarked')) {
            removeBookmark(username, questionId, roomId, button);
        } else {
            addBookmark(username, questionId, roomId, button);
        }
    }
    
    function removeBookmark(username, questionId, roomId, button) {
        showToast("Removing bookmark...", "info");
        
        fetch("/remove-bookmark-queston/", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ username, questionId, roomId })
        })
        .then(response => response.json())
        .then(data => {
            button.disabled = false;
            if (data.message === 'Bookmark removed successfully!') {
                button.classList.remove('bookmarked');
                showToast("Removed from bookmarks", "success");
            } else {
                showToast("Failed to remove bookmark", "error");
                console.error('Failed to remove bookmark:', data.error);
            }
        })
        .catch(error => {
            button.disabled = false;
            showToast("Network error", "error");
            console.error('Error removing bookmark:', error);
        });
    }
    
    function addBookmark(username, questionId, roomId, button) {
        showToast("Adding bookmark...", "info");
        
        fetch("/bookmark-questions/", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ username, questionId, roomId })
        })
        .then(response => response.json())
        .then(data => {
            button.disabled = false;
            if (data.message === 'Already bookmarked!') {
                button.classList.add('bookmarked');
                showToast("Already in your bookmarks", "info");
            } else if (data.message === 'Bookmark saved successfully!') {
                button.classList.add('bookmarked');
                showToast("Added to bookmarks", "success");
            } else {
                showToast("Failed to add bookmark", "error");
                console.error('Failed to add bookmark:', data.error);
            }
        })
        .catch(error => {
            button.disabled = false;
            showToast("Network error", "error");
            console.error('Error adding bookmark:', error);
        });
    }
    
    
    
    
    // A better toast notification system
    function showToast(message, type) {
        // Remove any existing toast
        const existingToast = document.getElementById('toast-notification');
        if (existingToast) {
            existingToast.remove();
        }
        
        // Create toast container if it doesn't exist
        let toastContainer = document.getElementById('toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.id = 'toast-container';
            toastContainer.style.position = 'fixed';
            toastContainer.style.bottom = '20px';
            toastContainer.style.right = '20px';
            toastContainer.style.zIndex = '9999';
            document.body.appendChild(toastContainer);
        }
        
        // Create toast
        const toast = document.createElement('div');
        toast.id = 'toast-notification';
        toast.style.backgroundColor = type === 'error' ? '#f44336' : 
                                      type === 'success' ? '#4CAF50' : 
                                      type === 'info' ? '#2196F3' : '#333';
        toast.style.color = 'white';
        toast.style.padding = '16px';
        toast.style.borderRadius = '4px';
        toast.style.marginTop = '10px';
        toast.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        toast.style.minWidth = '250px';
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        toast.textContent = message;
        
        // Add toast to container
        toastContainer.appendChild(toast);
        
        // Fade in
        setTimeout(() => {
            toast.style.opacity = '1';
        }, 10);
        
        // Fade out after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }
    
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    
        let socket;
        const roomId = "{{ room_id|escapejs }}";
        const socketUrl = `ws://${window.location.host}/ws/teachers-dashboard/hub-room/${roomId}/`;
        
        // Initialize WebSocket connection once
        function initializeWebSocket() {
        if (!socket || socket.readyState === WebSocket.CLOSED) {
            socket = new WebSocket(socketUrl);
    
            socket.onopen = function () {
                console.log(" WebSocket connection established.");
            };
    
            socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const messageData = data.message;
    
                    console.log(" Received messageData:", messageData);
    
                    if (messageData && messageData.question_id) {
                        console.log(" Processing reply:", messageData);
    
                        const replyText = messageData.message || "No reply content";
                        const messagesArea = document.getElementById('sidePanelMessages');
    
                        // Create reply element
                        const messageElement = document.createElement('div');
                        messageElement.classList.add('side-panel-message');
                        messageElement.innerHTML = `
                            <div class="reply">
                                <div class="reply-header">
                                    <span class="reply-info">${messageData.sender}</span>
                                    <span class="reply-role">(${messageData.role})</span>
                                </div>
                                <p class="reply-content">${replyText}</p>
                                <div class="reply-footer">
                                    <button class="vote-button upvote" data-reply-id="${messageData.reply_id}">
                                        <i class="fa fa-arrow-up"></i>
                                    </button>
                                    <span class="vote-count" id="vote-count-${messageData.reply_id}">
                                        ${messageData.upvotes - messageData.downvotes}
                                    </span>
                                    <button class="vote-button downvote" data-reply-id="${messageData.reply_id}">
                                        <i class="fa fa-arrow-down"></i>
                                    </button>
                                </div>
                            </div>
                        `;
    
                        messagesArea.appendChild(messageElement);
    
                        // Attach event listeners to the new buttons
                        messageElement.querySelectorAll(".vote-button").forEach(button => {
                            button.addEventListener("click", function () {
                                const replyId = this.dataset.replyId;
                                const voteType = this.classList.contains("upvote") ? "up" : "down";
                                vote(replyId, voteType); // Call your vote function
                            });
                        });
    
                    } else {
                        console.log(" Not a reply, ignoring.");
                    }
                } catch (error) {
                    console.error(" Error handling message:", error);
                }
            };
    
            socket.onerror = (e) => console.error(" WebSocket error:", e);
            socket.onclose = (e) => console.log(" WebSocket closed:", e);
        }
    }
    
    
        
        // Initialize WebSocket on page load
        initializeWebSocket();
        
        document.getElementById('sidePanelSendButton').addEventListener('click', function () {
            const inputField = document.getElementById('sidePanelInput');
            const replyText = inputField.value.trim();
        
            if (!replyText) {
                alert('Please enter a message before sending.');
                return;
            }
        
            if (!currentMessageId) {
                alert("Message ID is missing!");
                return;
            }
        
            inputField.value = ''; // Clear the input field
        
            const sender = "{{ current_teachers_name|escapejs }}";  
            const createdAt = new Date().toISOString();  
            const messageType = "text";  
            const upvotes = 0;  
            const downvotes = 0;  
        
            const messageData = {
                question_id: currentMessageId,
                message: replyText,
                sender: sender,
                created_at: createdAt,
                message_type: messageType,
                upvotes: upvotes,
                downvotes: downvotes,
                room_url: roomId,
                role: "TEACHER",
                reply: true
            };
        
            // Ensure WebSocket is open before sending
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(messageData));
            } else {
                console.error("WebSocket is not open. Reconnecting...");
                initializeWebSocket(); // Reinitialize if needed
                setTimeout(() => {
                    if (socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify(messageData));
                        console.log("I have sent the reply")
                    } else {
                        console.error("WebSocket connection failed.");
                    }
                }, 500); 
            }
        });
    
        document.addEventListener('DOMContentLoaded', function() {
        // Check if there's a questionId in sessionStorage
        const questionId = sessionStorage.getItem('openQuestionId');
        
        if (questionId) {
            // Clear it from session storage so it doesn't trigger again on refresh
            sessionStorage.removeItem('openQuestionId');
            
            // Find the message box with this question ID
            const messageBox = document.querySelector(`.message-box[data-message-id="${questionId}"]`);
            
            if (messageBox) {
                // Get the message content
                const messageContent = messageBox.getAttribute('data-message') || messageBox.textContent.trim();
                
                // Wait a moment for everything to load, then open the side panel
                setTimeout(() => {
                    // Open the side panel with this message
                    openSidePanel(messageContent, questionId);
                    
                    // Scroll to the message
                    messageBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Highlight the message temporarily
                    messageBox.style.boxShadow = '0 0 15px rgba(0, 123, 255, 0.7)';
                    setTimeout(() => {
                        messageBox.style.boxShadow = '';
                    }, 3000);
                }, 1000);
            } else {
                console.error(`Message with ID ${questionId} not found`);
            }
        }
    });
        
          </script>

</body>
</html>