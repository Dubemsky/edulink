{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>{{ hub }} - EduLink</title>
  <meta name="description" content="EduLink student hub room - collaborate with your teacher and classmates">
  <meta name="keywords" content="education, collaboration, student hub">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- jQuery -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- Vendor CSS Files -->
  <link href="{% static 'vendor/bootstrap/css/bootstrap.min.css' %}" rel="stylesheet">
  <link href="{% static 'vendor/bootstrap-icons/bootstrap-icons.css' %}" rel="stylesheet">
  <link href="{% static 'vendor/aos/aos.css' %}" rel="stylesheet">
  <link href="{% static 'vendor/glightbox/css/glightbox.min.css' %}" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <link href="{% static 'vendor/swiper/swiper-bundle.min.css' %}" rel="stylesheet">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

  <!-- Main CSS Files -->
  <link href="{% static 'css/main.css' %}" rel="stylesheet">
  <link href="{% static 'css/hub_room.css' %}" rel="stylesheet">
  <link rel="icon" href="{% static 'favicon.ico' %}" type="image/x-icon">
</head>

<body class="index-page">
  <header id="header" class="header d-flex align-items-center sticky-top">
    <div class="container-fluid container-xl d-flex align-items-center justify-content-between">
      <a href="{% url 'students_homepage' %}" class="logo d-flex align-items-center me-auto">
        <h1 class="sitename">EduLink</h1>
      </a>
      
      <h3 class="page-title">Chat Room: {{ hub }}</h3>

      <nav id="navmenu" class="navmenu">
        <ul>
          <li><a data-bs-toggle="modal" data-bs-target="#analyticsModal" style="cursor: pointer;">
            <i class="bi bi-bar-chart-line"></i> Analytics
          </a></li>
          <li><a href="{% url 'students_homepage' %}" class="active">
            <i class="bi bi-house"></i> Dashboard
          </a></li>
        </ul>
        <i class="mobile-nav-toggle d-xl-none bi bi-list"></i>
      </nav>
    </div>
  </header>

  <!-- Chat Room Section -->
  <section>
    <div class="container">
      <div class="rounded-container">
        <div class="chat-room">
          <aside class="chat-section">
            <div class="chat-messages" id="chatMessages" aria-live="polite" role="log">
              {% if messages %}
                {% for message in messages %}
                  <div class="message-box 
                    {% if message.is_current_user %}current-user-message{% elif message.role == 'teacher' %}teacher-message{% else %}other-user-message{% endif %}"
                    data-message="{{ message.content|escapejs }}"
                    data-message-id="{{ message.message_id }}"
                    {% if message.is_poll %} onclick="openSidePanel('{{ message.content|escapejs }}', '{{ message.message_id }}')" {% endif %}
                  >
                    <span class="message-sender">
                      {% if message.is_current_user %}
                        Me
                      {% else %}
                        {{ message.sender }}
                      {% endif %}
                    </span>
        
                    {% if message.image_url %}
                    <div class="message-image">
                      <a href="{{ message.image_url }}" target="_blank">
                        <img src="{{ message.image_url }}" alt="Shared image">
                      </a> 
                    </div>
                    {% endif %}
        
                    {% if message.file_url %}
                    <div class="message-file">
                      <a href="{{ message.file_url }}" target="_blank">
                        <img src="https://cdn-icons-png.flaticon.com/512/337/337946.png" alt="File">
                        <span>
                          {% if message.content and message.content != "my file" %}
                            {{ message.content }}
                          {% else %}
                            Download File
                          {% endif %}
                        </span>
                      </a>
                    </div>
                    {% endif %}
        
                    {% if message.video_url %}
                    <div class="message-video">
                      <video src="{{ message.video_url }}" controls></video>
                    </div>
                    {% endif %}
        
                    {% if message.content and message.content != message.image_url and not message.file_url and not message.is_poll %}
                    <div class="message-text">
                      {{ message.content|linebreaksbr }}
                    </div>
                    {% endif %}
        
                    {% if message.is_poll %}
                    <div class="message-poll">
                      <strong>{{ message.content }}</strong>
                      <form id="poll-form-{{ message.message_id }}" data-message-id="{{ message.message_id }}" data-room-id="{{message.room_id}}">
                        <ul>
                          {% for option in message.poll_options %}
                            <li>
                              <input type="radio" id="option-{{ message.message_id }}-{{ forloop.counter }}" name="poll-option-{{ message.message_id }}" value="{{ option.option }}">
                              <label for="option-{{ message.message_id }}-{{ forloop.counter }}">{{ option.option }}</label>
                              <span class="vote-count" id="vote-count-{{ message.message_id }}-{{ forloop.counter }}">{{ option.votes }}</span>
                            </li>
                          {% endfor %}
                        </ul>
                        <button type="button" class="poll-vote-button" id="poll-vote-{{ message.message_id }}" onclick="submitPollVote('{{ message.message_id }}', '{{message.room_id}}')">Vote</button>
                      </form>
                    </div>
                    {% endif %}
        
                    {% if message.top_reply_content != 'No replies yet.' and not message.is_poll %}
                    <div class="top-reply">
                      <div class="top-reply-content">
                        <strong>Top Reply:</strong> {{ message.top_reply_content }}
                      </div>
                      <div class="top-reply-votes">
                        <span class="upvote" title="Upvote"></span> {{ message.top_reply_upvotes }} 
                        | 
                        <span class="downvote" title="Downvote"></span> {{ message.top_reply_downvotes }}
                      </div>
                    </div>
                    {% elif not message.is_poll %}
                    <div class="top-reply no-reply">
                      <em>No replies yet.</em>
                    </div>
                    {% endif %}
        
                    <span class="message-time">{{ message.created_at }}</span>
                  </div>
                {% endfor %}
              {% else %}
                <p class="no-messages">No messages yet. Start a conversation!</p>
              {% endif %}
            </div>
                    
            <footer class="chat-input">
              <div class="input-group">
                <div style="position: relative; display: inline-block;">
                  <button type="button" id="attachFileButton" class="btn btn-light">
                    <i class="fa fa-plus"></i>
                  </button>
                
                  <div id="upload-menu" class="dropdown-menu">
                    <button class="dropdown-item" id="upload-file">
                      <i class="fa fa-paperclip"></i> Share File
                    </button>
                    <button class="dropdown-item" id="upload-video">
                      <i class="fa fa-video-camera"></i> Share Video
                    </button>
                  </div>
                </div>
          
                <input type="file" id="file-input" style="display: none;">
                <input type="file" id="videoInput" style="display: none;" accept="video/*">
          
                <input type="text" id="messageInput" placeholder="Type your message..." class="form-control">
                <div id="suggestionsBox" style="display: none;"></div>
                
                <button type="button" id="sendMessageButton" class="btn btn-primary">
                  <i class="fa fa-paper-plane"></i>
                </button>
              </div>
            </footer>
            
            <div id="fileMessageContainer" class="floating-message-box" style="display: none;">
              <textarea id="fileMessageInput" placeholder="Attach a message with your file..." rows="3"></textarea>
              <div class="button-group">
                <button id="cancelMessageButton">Cancel</button>
                <button id="sendAttachedMessageButton">Send</button>
              </div>
            </div>
          </aside>

          <!-- Right Sidebar -->
          <aside class="right-sidebar">
            <div class="user-head">
              <h3>Hub Resources</h3>
              <div class="tabs">
                <button class="tab-button active" id="membersBtn" data-tab="members">Members</button>
                <button class="tab-button" id="bookmarksBtn" data-tab="bookmarks">Bookmarks</button>
                <button class="tab-button" id="streamsBtn" data-tab="streams">Streams</button>
              </div>
            </div>
            
            <!-- Tab Content -->
            <div class="tab-content" id="members" style="display:block;">
              <h4>Members ({{ members|length }})</h4>
              <ul class="members-list">
                {% if members %}
                  {% for member in members %}
                    <li>{{ member }}</li>
                  {% endfor %}
                {% else %}
                  <li class="no-members">No members have joined this hub yet.</li>
                {% endif %}
              </ul>
            </div>
        
            <div class="tab-content" id="bookmarks">
              <h4>Bookmarks</h4>
              <ul class="bookmarks-list">
                {% if bookmarks %}
                  {% for bookmark in bookmarks %}
                    <div class="bookmark-item">
                      <button class="bookmark-button" onclick="openSidePanel('{{ bookmark.message }}', '{{ bookmark.question_id }}')">{{ bookmark.message }}</button>
                    </div>
                  {% endfor %}
                {% else %}
                  <div class="no-bookmarks">
                    No bookmarks available.
                  </div>
                {% endif %}
              </ul>
            </div>
        
            <div class="tab-content" id="streams">
              <h4>Streams</h4>
              <ul class="streams-list">
                {% if streams %}
                  {% for stream in streams %}
                    <li>{{ stream }}</li>
                  {% endfor %}
                {% else %}
                  <li class="no-streams">No streams available.</li>
                {% endif %}
              </ul>
            </div>
          </aside>
        </div>
      </div>
    </div>
  </section>

  <!-- Side Panel for Message Replies -->
  <!-- Side Panel for Message Replies with Truncated Title -->
<div id="side-panel" class="side-panel">
    <!-- Header with Sorting Options and Fixed Bookmark Button -->
    <div class="side-panel-header">
      <div class="header-content">
        <h2 id="panel-title" title="Full message will appear on hover">Message Title</h2>
        <div class="reply-sort-options">
          <button class="sort-button active" data-sort="recent">Recent</button>
          <button class="sort-button" data-sort="top">Top</button>
        </div>
      </div>
      <div class="bookmark-container">
        <button id="bookmark-button" class="bookmark-button circle">
          <i class="fa fa-bookmark"></i>
        </button>
      </div>
    </div>
  
    <!-- Messages Container -->
    <div class="side-panel-messages" id="sidePanelMessages">
      <!-- Dynamic content will be loaded here -->
    </div>
  
    <!-- Input Area -->
    <div class="side-panel-input">
      <input type="text" id="sidePanelInput" placeholder="Type your reply..." class="form-control">
      <button type="button" id="sidePanelSendButton"><i class="fa fa-paper-plane"></i></button>
    </div>
  </div>



  <!-- Analytics Modal -->
  <div class="modal fade" id="analyticsModal" tabindex="-1" aria-labelledby="analyticsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg analytics-modal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="analyticsModalLabel">Room Analytics: {{ hub }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <!-- Loading spinner -->
          <div class="spinner-container" id="analyticsSpinner">
            <div class="analytics-spinner"></div>
          </div>
          
          <!-- Analytics content (hidden initially) -->
          <div id="analyticsContent" style="display: none;">
            <!-- Analytics Tabs -->
            <div class="analytics-tabs">
              <div class="analytics-tab active" data-tab="overview">Overview</div>
              <div class="analytics-tab" data-tab="engagement">User Engagement</div>
              <div class="analytics-tab" data-tab="activity">Activity Timeline</div>
              <div class="analytics-tab" data-tab="polls">Poll Results</div>
            </div>
            
            <!-- Overview Tab -->
            <div class="analytics-tab-content active" id="overview-tab">
              <div class="row">
                <div class="col-md-3">
                  <div class="analytics-stat">
                    <div class="stat-value" id="total-messages">0</div>
                    <div class="stat-label">Total Messages</div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="analytics-stat">
                    <div class="stat-value" id="total-replies">0</div>
                    <div class="stat-label">Total Replies</div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="analytics-stat">
                    <div class="stat-value" id="total-participants">0</div>
                    <div class="stat-label">Participants</div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="analytics-stat">
                    <div class="stat-value" id="total-reactions">0</div>
                    <div class="stat-label">Total Reactions</div>
                  </div>
                </div>
              </div>
              
              <div class="analytics-card">
                <div class="analytics-card-header">
                  <h5>Message Types</h5>
                </div>
                <div class="analytics-card-body">
                  <div class="chart-container">
                    <canvas id="messageTypesChart"></canvas>
                  </div>
                  <div id="message-types-legend" class="text-center mt-3"></div>
                </div>
              </div>
            </div>
            
            <!-- Remaining analytics tabs content -->
            <!-- User Engagement Tab -->
            <div class="analytics-tab-content" id="engagement-tab">
              <!-- Content will be populated by JavaScript -->
            </div>
            
            <!-- Activity Timeline Tab -->
            <div class="analytics-tab-content" id="activity-tab">
              <!-- Content will be populated by JavaScript -->
            </div>
            
            <!-- Poll Results Tab -->
            <div class="analytics-tab-content" id="polls-tab">
              <!-- Content will be populated by JavaScript -->
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Add CSRF token -->
  <script>
    document.cookie = "csrftoken={{ csrf_token }}";
  </script>

  <!-- Vendor JS Files -->
  <script src="{% static 'vendor/bootstrap/js/bootstrap.bundle.min.js' %}"></script>
  <script src="{% static 'vendor/aos/aos.js' %}"></script>
  <script src="{% static 'vendor/purecounter/purecounter_vanilla.js' %}"></script>
  <script src="{% static 'vendor/glightbox/js/glightbox.min.js' %}"></script>
  <script src="{% static 'vendor/swiper/swiper-bundle.min.js' %}"></script>

  <!-- Main JS Files -->
  <script src="{% static 'js/main.js' %}"></script>
  
  <script>
    const RoomAnalytics = (function() {
        // Private properties
        let analyticsData = null;
        let charts = {};
        
        // Cache DOM elements
        const $modal = document.getElementById('analyticsModal');
        const $spinner = document.getElementById('analyticsSpinner');
        const $content = document.getElementById('analyticsContent');
        const $tabs = document.querySelectorAll('.analytics-tab');
        const $tabContents = document.querySelectorAll('.analytics-tab-content');
        
        // Initialize the module
        function init(roomId) {
            // Add event listener to tabs
            $tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });
            
            // Add event listener to modal
            if ($modal) {
                $modal.addEventListener('shown.bs.modal', function() {
                    if (!analyticsData) {
                        fetchAnalytics(roomId);
                    }
                });
                
                $modal.addEventListener('hidden.bs.modal', function() {
                    // Optional: Clear data when modal is closed to refresh on next open
                    // analyticsData = null;
                    
                    // Destroy charts to prevent memory leaks
                    Object.values(charts).forEach(chart => {
                        if (chart && typeof chart.destroy === 'function') {
                            chart.destroy();
                        }
                    });
                    charts = {};
                });
            }
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update active tab
            $tabs.forEach(tab => {
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            // Update active content
            $tabContents.forEach(content => {
                if (content.id === `${tabName}-tab`) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
        }
        
        // Fetch analytics data from the server
        function fetchAnalytics(roomId) {
            showLoading();
            
            fetch(`/room-analytics/${roomId}/`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Server responded with status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        analyticsData = data.analytics;
                        renderAnalytics();
                    } else {
                        showError(data.error || 'Failed to load analytics');
                    }
                })
                .catch(error => {
                    console.error('Error fetching analytics:', error);
                    showError('Network error while loading analytics');
                })
                .finally(() => {
                    hideLoading();
                });
        }
        
        // Show loading spinner
        function showLoading() {
            if ($spinner) $spinner.style.display = 'flex';
            if ($content) $content.style.display = 'none';
        }
        
        // Hide loading spinner
        function hideLoading() {
            if ($spinner) $spinner.style.display = 'none';
            if ($content) $content.style.display = 'block';
        }
        
        // Show error message
        function showError(message) {
            if ($content) {
                $content.innerHTML = `
                    <div class="alert alert-danger" role="alert">
                        <i class="fa fa-exclamation-circle"></i> ${message}
                    </div>
                `;
                $content.style.display = 'block';
            }
        }
        
        // Render all analytics components
        function renderAnalytics() {
            if (!analyticsData) return;
            
            try {
                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js is not loaded. Loading dynamically...');
                    // Try to load Chart.js dynamically
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js';
                    script.onload = function() {
                        console.log('Chart.js loaded successfully, rendering analytics...');
                        renderAnalyticsComponents();
                    };
                    script.onerror = function() {
                        console.error('Failed to load Chart.js dynamically');
                        showError('Failed to load chart library. Please refresh the page.');
                    };
                    document.head.appendChild(script);
                } else {
                    renderAnalyticsComponents();
                }
            } catch (error) {
                console.error('Error rendering analytics:', error);
                showError('Error rendering analytics data');
            }
        }
        
        // Render all analytics components after ensuring Chart.js is available
        function renderAnalyticsComponents() {
            try {
                // Render overview stats
                renderOverviewStats();
                
                // Render message types chart
                renderMessageTypesChart();
                
                // Render user engagement charts
                renderTopContributorsChart();
                renderParticipantTable();
                
                // Render activity timeline
                renderActivityTimeline();
                
                // Render poll results
                renderPollResults();
            } catch (error) {
                console.error('Error rendering analytics components:', error);
                showError('Error rendering analytics data');
            }
        }
        
        // Render overview statistics
        function renderOverviewStats() {
            const metrics = analyticsData.message_metrics;
            
            // Update stat values safely
            const totalMessagesEl = document.getElementById('total-messages');
            if (totalMessagesEl) totalMessagesEl.textContent = metrics.total_messages;
            
            const totalRepliesEl = document.getElementById('total-replies');
            if (totalRepliesEl) totalRepliesEl.textContent = metrics.total_replies;
            
            const totalParticipantsEl = document.getElementById('total-participants');
            if (totalParticipantsEl) totalParticipantsEl.textContent = metrics.total_participants;
            
            // Total reactions
            const totalReactions = (metrics.total_reactions.upvotes || 0) + (metrics.total_reactions.downvotes || 0);
            const totalReactionsEl = document.getElementById('total-reactions');
            if (totalReactionsEl) totalReactionsEl.textContent = totalReactions;
        }
        
        // Render message types chart
        function renderMessageTypesChart() {
            const messageTypes = analyticsData.message_metrics.message_types || {};
            const chartCanvas = document.getElementById('messageTypesChart');
            
            if (!chartCanvas) return;
            
            // Check if Chart.js is available
            if (typeof Chart === 'undefined') {
                console.error('Chart.js is not loaded. Cannot render chart.');
                const container = chartCanvas.parentElement;
                if (container) {
                    container.innerHTML = '<div class="alert alert-warning">Chart library not available. Please check if Chart.js is properly loaded.</div>';
                }
                return;
            }
            
            const ctx = chartCanvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (charts.messageTypes) {
                charts.messageTypes.destroy();
            }
            
            // Create legend for message types
            const legendContainer = document.getElementById('message-types-legend');
            if (legendContainer) {
                legendContainer.innerHTML = '';
            }
            
            // Define colors for message types
            const typeColors = {
                'text': '#6c757d',
                'image': '#28a745',
                'file': '#dc3545',
                'video': '#fd7e14',
                'poll': '#17a2b8'
            };
            
            // Format data for the chart
            const labels = [];
            const data = [];
            const backgroundColor = [];
            
            // Add a pill for each message type
            Object.entries(messageTypes).forEach(([type, count]) => {
                labels.push(type);
                data.push(count);
                backgroundColor.push(typeColors[type] || '#6c757d');
                
                // Create legend item if container exists
                if (legendContainer) {
                    const pill = document.createElement('span');
                    pill.className = `message-type-pill message-type-${type}`;
                    pill.textContent = `${type}: ${count}`;
                    legendContainer.appendChild(pill);
                }
            });
            
            // Only create chart if we have data
            if (labels.length > 0) {
                // Create the chart
                charts.messageTypes = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: data,
                            backgroundColor: backgroundColor,
                            borderColor: '#ffffff',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        animation: {
                            animateScale: true,
                            animateRotate: true
                        }
                    }
                });
            } else {
                // Show a message if no data
                if (legendContainer) {
                    legendContainer.innerHTML = '<p>No message type data available</p>';
                }
            }
        }
        
        // Render top contributors chart
        function renderTopContributorsChart() {
            const contributors = analyticsData.user_engagement.top_contributors || [];
            const chartCanvas = document.getElementById('topContributorsChart');
            
            if (!chartCanvas) return;
            
            // Check if Chart.js is available
            if (typeof Chart === 'undefined') {
                console.error('Chart.js is not loaded. Cannot render chart.');
                const container = chartCanvas.parentElement;
                if (container) {
                    container.innerHTML = '<div class="alert alert-warning">Chart library not available. Please check if Chart.js is properly loaded.</div>';
                }
                return;
            }
            
            const ctx = chartCanvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (charts.topContributors) {
                charts.topContributors.destroy();
            }
            
            // Format data for the chart
            const labels = contributors.map(c => c.name || 'Unknown');
            const data = contributors.map(c => c.messages || 0);
            
            // Only create chart if we have data
            if (labels.length > 0) {
                // Create the chart
                charts.topContributors = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Number of Messages',
                            data: data,
                            backgroundColor: '#007bff',
                            borderColor: '#0056b3',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            } else {
                // Show a message if no data
                chartCanvas.parentElement.innerHTML = '<p>No contributor data available</p>';
            }
        }
        
        // Render participant table
        function renderParticipantTable() {
            const contributors = analyticsData.user_engagement.top_contributors || [];
            const totalMessages = analyticsData.message_metrics.total_messages || 0;
            const tableBody = document.querySelector('#participantTable tbody');
            
            if (!tableBody) return;
            
            tableBody.innerHTML = '';
            
            if (contributors.length === 0) {
                const emptyRow = document.createElement('tr');
                const emptyCell = document.createElement('td');
                emptyCell.colSpan = 3;
                emptyCell.textContent = 'No participant data available';
                emptyCell.className = 'text-center';
                emptyRow.appendChild(emptyCell);
                tableBody.appendChild(emptyRow);
                return;
            }
            
            // Create a row for each participant
            contributors.forEach(contributor => {
                const row = document.createElement('tr');
                
                // Participant name
                const nameCell = document.createElement('td');
                nameCell.textContent = contributor.name || 'Unknown';
                row.appendChild(nameCell);
                
                // Number of messages
                const messagesCell = document.createElement('td');
                messagesCell.textContent = contributor.messages || 0;
                row.appendChild(messagesCell);
                
                // Participation bar
                const participationCell = document.createElement('td');
                const percentage = totalMessages > 0 ? 
                    (((contributor.messages || 0) / totalMessages) * 100).toFixed(1) : 0;
                
                const progressContainer = document.createElement('div');
                progressContainer.className = 'progress-bar-container';
                
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                progressBar.style.width = `${percentage}%`;
                
                progressContainer.appendChild(progressBar);
                
                const percentageText = document.createElement('small');
                percentageText.textContent = `${percentage}%`;
                percentageText.style.marginLeft = '8px';
                
                participationCell.appendChild(progressContainer);
                participationCell.appendChild(percentageText);
                row.appendChild(participationCell);
                
                tableBody.appendChild(row);
            });
        }
        
        // Render activity timeline
        function renderActivityTimeline() {
            const timeline = analyticsData.activity_timeline || [];
            const chartCanvas = document.getElementById('activityTimelineChart');
            
            if (!chartCanvas) return;
            
            // Check if Chart.js is available
            if (typeof Chart === 'undefined') {
                console.error('Chart.js is not loaded. Cannot render chart.');
                const container = chartCanvas.parentElement;
                if (container) {
                    container.innerHTML = '<div class="alert alert-warning">Chart library not available. Please check if Chart.js is properly loaded.</div>';
                }
                return;
            }
            
            const ctx = chartCanvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (charts.activityTimeline) {
                charts.activityTimeline.destroy();
            }
            
            // Format data for the chart
            const labels = timeline.map(t => t.date || '');
            const data = timeline.map(t => t.count || 0);
            
            // Only create chart if we have data
            if (labels.length > 0) {
                // Create the chart
                charts.activityTimeline = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Messages',
                            data: data,
                            backgroundColor: 'rgba(0, 123, 255, 0.1)',
                            borderColor: '#007bff',
                            borderWidth: 2,
                            pointBackgroundColor: '#007bff',
                            pointRadius: 4,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            } else {
                // Show a message if no data
                chartCanvas.parentElement.innerHTML = '<p>No activity timeline data available</p>';
            }
        }
        
        // Render poll results
        function renderPollResults() {
            const polls = analyticsData.polls || [];
            const container = document.getElementById('pollResults');
            const noPollsMessage = document.getElementById('no-polls-message');
            
            if (!container) return;
            
            // Clear previous content
            container.innerHTML = '';
            
            if (!polls || polls.length === 0) {
                if (noPollsMessage) noPollsMessage.style.display = 'block';
                return;
            }
            
            if (noPollsMessage) noPollsMessage.style.display = 'none';
            
            // Create a card for each poll
            polls.forEach(poll => {
                const pollCard = document.createElement('div');
                pollCard.className = 'poll-result';
                
                // Poll question
                const question = document.createElement('div');
                question.className = 'poll-question';
                question.textContent = poll.question || 'Unnamed Poll';
                pollCard.appendChild(question);
                
                // Get poll options or create empty array
                const options = poll.options || [];
                
                if (options.length === 0) {
                    const emptyMessage = document.createElement('p');
                    emptyMessage.textContent = 'No options available for this poll';
                    pollCard.appendChild(emptyMessage);
                    container.appendChild(pollCard);
                    return;
                }
                
                // Calculate total votes for percentage
                const totalVotes = options.reduce((sum, option) => sum + (option.votes || 0), 0);
                
                // Poll options
                options.forEach(option => {
                    const optionElement = document.createElement('div');
                    optionElement.className = 'poll-option';
                    
                    // Option text and votes
                    const optionText = document.createElement('div');
                    optionText.className = 'poll-option-text';
                    
                    const optionLabel = document.createElement('span');
                    optionLabel.textContent = option.option || 'Unnamed Option';
                    
                    const votes = option.votes || 0;
                    const optionVotes = document.createElement('span');
                    optionVotes.textContent = `${votes} vote${votes !== 1 ? 's' : ''}`;
                    
                    optionText.appendChild(optionLabel);
                    optionText.appendChild(optionVotes);
                    optionElement.appendChild(optionText);
                    
                    // Progress bar
                    const barContainer = document.createElement('div');
                    barContainer.className = 'poll-option-bar';
                    
                    const percentage = totalVotes > 0 ? ((option.votes || 0) / totalVotes) * 100 : 0;
                    
                    const bar = document.createElement('div');
                    bar.className = 'poll-option-progress';
                    bar.style.width = `${percentage}%`;
                    
                    barContainer.appendChild(bar);
                    optionElement.appendChild(barContainer);
                    
                    // Percentage
                    const percentText = document.createElement('div');
                    percentText.className = 'text-right';
                    percentText.innerHTML = `<small>${percentage.toFixed(1)}%</small>`;
                    
                    optionElement.appendChild(percentText);
                    
                    pollCard.appendChild(optionElement);
                });
                
                container.appendChild(pollCard);
            });
        }
        
        // Public methods
        return {
            init: init,
            fetchAnalytics: fetchAnalytics
        };
    })();
    
    // Initialize analytics when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Get room ID from the URL or a data attribute
        const roomIdElement = document.getElementById('room-id-data');
        let roomId;
        
        if (roomIdElement) {
            roomId = roomIdElement.getAttribute('data-room-id');
        } else if (typeof currentRoomId !== 'undefined') {
            roomId = currentRoomId;
        } else {
            console.error('Room ID not found. Analytics cannot be initialized.');
            return;
        }
        
        if (roomId) {
            // Initialize analytics module
            RoomAnalytics.init(roomId);
            
            // Add event listener to analytics button
            const analyticsButton = document.querySelector('a[href="#analytics"]');
            if (analyticsButton) {
                analyticsButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    // Check if Bootstrap is loaded
                    if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                        const analyticsModal = new bootstrap.Modal(document.getElementById('analyticsModal'));
                        analyticsModal.show();
                    } else {
                        // Fallback if bootstrap is not loaded
                        const modalElement = document.getElementById('analyticsModal');
                        if (modalElement) {
                            modalElement.style.display = 'block';
                            modalElement.classList.add('show');
                        }
                    }
                });
            }
        }
    });
    
    
    
    
    
    
    
        
    const currentRoomId = "{{ room_id|escapejs }}";
    const currentUserName = "{{ current_student_name|escapejs }}";
    // Add CSS for toast notifications
    document.head.insertAdjacentHTML('beforeend', `
    <style>
    #toast-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 9999;
    }
    </style>
    `);
    
    
    
    
    // User's poll votes storage
    const userPollVotes = {}; // Format: { pollId: selectedOption }
    
    // Function to submit a poll vote
    function submitPollVote(messageId, roomId) {
        const form = document.getElementById(`poll-form-${messageId}`);
        const selectedOption = form.querySelector(`input[name="poll-option-${messageId}"]:checked`);
        const voteButton = document.getElementById(`poll-vote-${messageId}`);
        
        // If user has already voted for this poll
        if (userPollVotes[messageId]) {
            showToast("You've already voted in this poll", "info");
            return;
        }
        
        if (!selectedOption) {
            showToast("Please select an option", "error");
            return;
        }
        
        const selectedValue = selectedOption.value;
        
        // Disable the vote button during submission
        voteButton.disabled = true;
        voteButton.textContent = "Voting...";
        
        fetch("/poll-voting/", { 
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                "X-CSRFToken": getCookie("csrftoken"),
            },
            body: JSON.stringify({
                message_id: messageId,
                room_id: roomId,
                selected_option: selectedValue,
                username: currentUserName
            }),
        })
        .then(response => response.json())
        .then(data => {
            voteButton.disabled = false;
            voteButton.textContent = "Vote";
            
            if (data.success) {
                // Update the vote counts in the UI
                data.poll_options.forEach((option, index) => {
                    const voteCountElement = document.getElementById(`vote-count-${messageId}-${index + 1}`);
                    if (voteCountElement) {
                        voteCountElement.textContent = option.votes;
                    }
                });
                
                // Store the user's vote
                userPollVotes[messageId] = selectedValue;
                
                // Change the UI to show the user has voted
                markPollAsVoted(messageId, selectedValue);
                
                showToast("Vote submitted successfully", "success");
            } else {
                if (data.error === "already_voted") {
                    showToast("You've already voted in this poll", "info");
                    
                    // Update the UI to reflect the user's previous vote
                    if (data.user_vote) {
                        userPollVotes[messageId] = data.user_vote;
                        markPollAsVoted(messageId, data.user_vote);
                    }
                } else {
                    showToast("Failed to submit vote", "error");
                }
            }
        })
        .catch(error => {
            console.error('Error:', error);
            voteButton.disabled = false;
            voteButton.textContent = "Vote";
            showToast("An error occurred", "error");
        });
    }
    
    // Function to mark a poll as voted for this user
    function markPollAsVoted(messageId, selectedValue) {
        const form = document.getElementById(`poll-form-${messageId}`);
        const voteButton = document.getElementById(`poll-vote-${messageId}`);
        const radioButtons = form.querySelectorAll(`input[type="radio"]`);
        
        // Disable all radio buttons
        radioButtons.forEach(radio => {
            radio.disabled = true;
            
            // Highlight the user's choice
            if (radio.value === selectedValue) {
                radio.checked = true;
                radio.parentElement.classList.add('user-voted');
            }
        });
        
        // Change the vote button to show "Voted"
        voteButton.textContent = "Voted";
        voteButton.disabled = true;
        voteButton.classList.add('voted');
        
        // Add a class to the form to show it's been voted on
        form.classList.add('voted');
    }
    
    // Function to check user's poll votes when loading the page
    function checkUserPollVotes() {
        // Get all poll IDs on the page
        const pollForms = document.querySelectorAll('form[id^="poll-form-"]');
        const pollIds = Array.from(pollForms).map(form => form.dataset.messageId);
        
        if (pollIds.length === 0) return;
        
        fetch("/check-poll-votes/", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                username: currentUserName,
                poll_ids: pollIds
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success && data.votes) {
                // Update userPollVotes and UI for each poll
                Object.entries(data.votes).forEach(([pollId, voteInfo]) => {
                    userPollVotes[pollId] = voteInfo.option;
                    markPollAsVoted(pollId, voteInfo.option);
                });
            }
        })
        .catch(error => {
            console.error('Error checking poll votes:', error);
        });
    }
    
    // Add CSS for voted polls
    const pollStyles = `
    .poll-vote-button.voted {
        background-color: #4CAF50;
        cursor: default;
    }
    
    form.voted .pollOptionInput {
        opacity: 0.7;
    }
    
    li.user-voted {
        background-color: rgba(76, 175, 80, 0.1);
        border-radius: 4px;
        padding: 4px;
    }
    
    .poll-results-bar {
        height: 10px;
        background-color: #e0e0e0;
        border-radius: 5px;
        margin-top: 4px;
        position: relative;
        overflow: hidden;
    }
    
    .poll-results-fill {
        height: 100%;
        background-color: #2196F3;
        border-radius: 5px;
        transition: width 0.5s ease-in-out;
    }
    
    .poll-option-votes {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 2px;
    }
    
    .poll-option-text {
        flex-grow: 1;
        margin-right: 10px;
    }
    
    .poll-option-count {
        font-weight: bold;
        min-width: 30px;
        text-align: right;
    }
    `;
    
    // Add the styles to the head
    document.head.insertAdjacentHTML('beforeend', `<style>${pollStyles}</style>`);
    
    // Call this function when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Check user's poll votes
        checkUserPollVotes();
    });
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    document.addEventListener('DOMContentLoaded', function () {
        // Access the roomId passed from Django context
        const roomId = "{{ room_id|escapejs }}";  // Ensure the roomId is properly passed from Django context
    
        // Set up a timeout for debouncing the input
        let debounceTimeout;
    
        // Listen for input event in the message input field
        document.getElementById('messageInput').addEventListener('input', async (event) => {
            const query = event.target.value.trim();
    
            // Log the query to check what the user is typing
            console.log("User input:", query);
    
            // Clear the previous timeout to implement debouncing
            clearTimeout(debounceTimeout);
    
            if (query.length > 0) {
                // Show the suggestion box when the user types
                document.getElementById('suggestionsBox').style.display = 'block';
    
                // Set a timeout to make the request after the user stops typing for 300ms
                debounceTimeout = setTimeout(async () => {
                    try {
                        console.log("Making request with query:", query, "and roomId:", roomId);
    
                        // Call the backend to get similar questions based on roomId and query
                        const response = await fetch(`/get_suggestions/?query=${encodeURIComponent(query)}&room_id=${encodeURIComponent(roomId)}`);
    
                        if (response.ok) {
                            const suggestions = await response.json();
                            console.log("Suggestions received:", suggestions);  // Log the suggestions received from the server
                            showSuggestions(suggestions);
                        } else {
                            console.error('Failed to fetch suggestions:', response.status);
                            document.getElementById('suggestionsBox').style.display = 'none';
                        }
                    } catch (error) {
                        console.error('Error fetching suggestions:', error);
                        document.getElementById('suggestionsBox').style.display = 'none';
                    }
                }, 300); // 300ms debounce time
            } else {
                // Hide the suggestion box when the input is empty
                document.getElementById('suggestionsBox').style.display = 'none';
            }
        });
    
        document.addEventListener('click', function(event) {
            const suggestionsBox = document.getElementById('suggestionsBox');
            const messageInput = document.getElementById('messageInput');
    
            // Check if the clicked element is inside the suggestions box or the input field
            if (!suggestionsBox.contains(event.target) && event.target !== messageInput) {
                suggestionsBox.style.display = 'none'; // Hide the box
            }
        });
    
    
        // Function to display suggestions
        function showSuggestions(suggestions) {
        const suggestionsBox = document.getElementById('suggestionsBox');
        suggestionsBox.innerHTML = ''; // Clear any old suggestions
    
        if (!suggestions || !suggestions.suggestions || suggestions.suggestions.length === 0) {
            // If there are no suggestions, show a "no results" message
            const noResult = document.createElement('div');
            noResult.textContent = 'No suggestions found';
            suggestionsBox.appendChild(noResult);
            return; // Stop the function here
        }
    
        // Loop through each suggestion and create a button
        suggestions.suggestions.forEach(suggestion => {
            const button = document.createElement('button');
            button.textContent = suggestion.question; // Use the question as the button text
            button.classList.add('suggestion-button'); // Add a class for styling
    
            // When the button is clicked, open the side panel
            button.addEventListener('click', () => {
                openSidePanel(suggestion.question, suggestion.message_id);
            });
    
            suggestionsBox.appendChild(button); // Add the button to the suggestion box
        });
    }
    });
    
    
    
    
    
    
    
    document.addEventListener("DOMContentLoaded", function () {
        const tabButtons = document.querySelectorAll(".tab-button");
        const tabContents = document.querySelectorAll(".tab-content");
        const roomId = "{{ room_id|escapejs }}";
        const currentStudentName = "{{ current_student_name|escapejs }}";
    
        tabButtons.forEach(button => {
            button.addEventListener("click", function () {
                const tabName = this.getAttribute("data-tab");
                sendTabClickData(tabName, roomId, currentStudentName);
    
                tabContents.forEach(content => {
                    content.style.display = "none";
                });
    
                document.getElementById(tabName).style.display = "block";
    
                tabButtons.forEach(btn => btn.classList.remove("active"));
                this.classList.add("active");
    
                if (tabName === "bookmarks") {
                    fetchBookmarks(roomId, currentStudentName);
                }
            });
        });
    
        function sendTabClickData(tabName, room_id, username) {
            fetch("/log-tab-click/", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": getCookie("csrftoken"),
                },
                body: JSON.stringify({ tab_name: tabName, roomId: room_id, username: username })
            })
            .then(response => response.json())
            .then(data => console.log("Tab click logged:", data))
            .catch(error => console.error("Error logging tab click:", error));
        }
    
        function fetchBookmarks(room_id, username) {
            fetch("/log-tab-click/", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": getCookie("csrftoken"),
                },
                body: JSON.stringify({ tab_name: "bookmarked", roomId: room_id, username: username })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === "success" && data.bookmarked_messages) {
                    updateBookmarksUI(data.bookmarked_messages);
                } else {
                    console.error("Error fetching bookmarks:", data.message);
                }
            })
            .catch(error => console.error("Fetch error:", error));
        }
    
        function updateBookmarksUI(bookmarks) {
            const bookmarksList = document.querySelector(".bookmarks-list");
            bookmarksList.innerHTML = ""; // Clear previous content
    
            if (bookmarks.length > 0) {
                bookmarks.forEach(bookmark => {
                    const listItem = document.createElement("li");
                    const button = document.createElement("button");
                    button.textContent = bookmark.message;
                    button.classList.add("bookmark-button");
                    button.onclick = function() {
                        openSidePanel(bookmark.message, bookmark.question_id);
                    };
                    listItem.appendChild(button);
                    bookmarksList.appendChild(listItem);
                });
            } else {
                bookmarksList.innerHTML = "<li>No bookmarks available.</li>";
            }
        }
    
        function getCookie(name) {
            const cookies = document.cookie.split("; ");
            for (let cookie of cookies) {
                let [key, value] = cookie.split("=");
                if (key === name) return decodeURIComponent(value);
            }
        }
    });
    
    
    
    
    
    
    
    
    const userVotes = {}; // To track user votes: {replyId: "up"|"down"|null}
    
    function attachVoteHandlers() {
        // Add event listeners to all vote buttons
        document.querySelectorAll(".vote-button").forEach(button => {
            button.addEventListener("click", function() {
                const replyId = this.dataset.replyId;
                const voteType = this.classList.contains("upvote") ? "up" : "down";
                handleVote(replyId, voteType, this);
            });
        });
    }
    
    function handleVote(replyId, voteType, buttonElement) {
        // Get the opposing button (if upvote was clicked, get the downvote button and vice versa)
        const container = buttonElement.closest('.reply-footer');
        const upvoteButton = container.querySelector('.upvote');
        const downvoteButton = container.querySelector('.downvote');
        const voteCountElement = container.querySelector('.vote-count');
        const currentVoteCount = parseInt(voteCountElement.textContent.trim(), 10) || 0;
        
        // Get current vote state for this reply
        const currentVote = userVotes[replyId];
        
        // User is clicking the same button they already voted on - remove vote
        if (currentVote === voteType) {
            // Remove vote styling
            buttonElement.classList.remove('voted');
            
            // Send request to remove vote
            sendVoteRequest(replyId, 'remove', currentVoteCount, voteCountElement);
            
            // Update tracking
            userVotes[replyId] = null;
            
            showToast(`Vote removed`, "info");
            return;
        }
        
        // User is changing vote from one type to another
        if (currentVote && currentVote !== voteType) {
            // Remove styling from previous vote
            if (currentVote === 'up') {
                upvoteButton.classList.remove('voted');
            } else {
                downvoteButton.classList.remove('voted');
            }
            
            // Add styling to new vote
            buttonElement.classList.add('voted');
            
            // Send request to change vote
            sendVoteRequest(replyId, 'change', currentVoteCount, voteCountElement, voteType, currentVote);
            
            // Update tracking
            userVotes[replyId] = voteType;
            
            showToast(`Vote changed to ${voteType}vote`, "info");
            return;
        }
        
        // User is voting for the first time
        buttonElement.classList.add('voted');
        
        // Send request to add vote
        sendVoteRequest(replyId, 'add', currentVoteCount, voteCountElement, voteType);
        
        // Update tracking
        userVotes[replyId] = voteType;
        
        showToast(`${voteType === 'up' ? 'Upvoted' : 'Downvoted'} reply`, "success");
    }
    
    function sendVoteRequest(replyId, action, currentCount, countElement, newVote = null, oldVote = null) {
        // Immediately update the UI optimistically
        let newCount = currentCount;
        
        if (action === 'add') {
            newCount += newVote === 'up' ? 1 : -1;
        } else if (action === 'remove') {
            newCount += userVotes[replyId] === 'up' ? -1 : 1;
        } else if (action === 'change') {
            // If changing from up to down, that's -2 (remove up, add down)
            // If changing from down to up, that's +2 (remove down, add up)
            newCount += newVote === 'up' ? 2 : -2;
        }
        
        // Update the UI immediately
        countElement.textContent = newCount;
        
        // Make the API request
        fetch('/vote-reply/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                reply_id: replyId,
                vote_type: newVote,
                username: currentUserName,
                action: action,
                old_vote: oldVote
            })
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                // If there was an error, revert the UI
                countElement.textContent = currentCount;
                showToast(data.error || "Error updating vote", "error");
                
                // Revert the vote tracking
                if (action === 'add') {
                    userVotes[replyId] = null;
                } else if (action === 'remove') {
                    userVotes[replyId] = oldVote;
                } else if (action === 'change') {
                    userVotes[replyId] = oldVote;
                }
                
                // Revert the UI classes
                const container = countElement.closest('.reply-footer');
                const upvoteButton = container.querySelector('.upvote');
                const downvoteButton = container.querySelector('.downvote');
                
                upvoteButton.classList.remove('voted');
                downvoteButton.classList.remove('voted');
                
                if (userVotes[replyId] === 'up') {
                    upvoteButton.classList.add('voted');
                } else if (userVotes[replyId] === 'down') {
                    downvoteButton.classList.add('voted');
                }
            } else {
                // Update the count with the actual value from the server
                if (data.newCount !== undefined) {
                    countElement.textContent = data.newCount;
                }
            }
        })
        .catch(error => {
            console.error('Error updating vote:', error);
            showToast("Network error while voting", "error");
            
            // Revert the UI
            countElement.textContent = currentCount;
        });
    }
    
    // Function to get the current vote for a reply
    function fetchUserVotes() {
        // Get all reply IDs currently visible in the side panel
        const replyIds = [];
        document.querySelectorAll('.reply-footer .vote-button').forEach(button => {
            const replyId = button.dataset.replyId;
            if (replyId && !replyIds.includes(replyId)) {
                replyIds.push(replyId);
            }
        });
        
        if (replyIds.length === 0) return;
        
        // Fetch vote status for these replies
        fetch('/get-user-votes/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                username: currentUserName,
                reply_ids: replyIds
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.votes) {
                // Update userVotes and UI
                Object.entries(data.votes).forEach(([replyId, voteType]) => {
                    userVotes[replyId] = voteType;
                    
                    // Update UI to show voted state
                    const container = document.querySelector(`.vote-button[data-reply-id="${replyId}"]`).closest('.reply-footer');
                    const upvoteButton = container.querySelector('.upvote');
                    const downvoteButton = container.querySelector('.downvote');
                    
                    upvoteButton.classList.remove('voted');
                    downvoteButton.classList.remove('voted');
                    
                    if (voteType === 'up') {
                        upvoteButton.classList.add('voted');
                    } else if (voteType === 'down') {
                        downvoteButton.classList.add('voted');
                    }
                });
            }
        })
        .catch(error => {
            console.error('Error fetching vote status:', error);
        });
    }
    
    // CSS for voted buttons
    const voteStyles = `
    .vote-button.voted {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
    }
    .vote-button.upvote.voted i {
        color: white;
    }
    .vote-button.downvote.voted i {
        color: white;
    }
    `;
    
    // Add the styles to the head
    document.head.insertAdjacentHTML('beforeend', `<style>${voteStyles}</style>`);
    
    
    
    
    
    
    
    document.addEventListener("DOMContentLoaded", function () {
        const attachFileButton = document.getElementById("attachFileButton");
        const uploadMenu = document.getElementById("upload-menu");
        const uploadFileButton = document.getElementById("upload-file");
        const uploadVideoButton = document.getElementById("upload-video");
        const fileInput = document.getElementById("file-input");
        const videoInput = document.getElementById("videoInput");  // Video input for videos
        const messageInput = document.getElementById("messageInput"); // Input for the message
        const fileMessageInput = document.getElementById("fileMessageInput"); // Input for the file message
        const fileMessageContainer = document.getElementById("fileMessageContainer"); // Floating message box container
        let selectedFile = null;
        let selectedVideo = null;
        const roomId = "{{ room_id|escapejs }}";
        const currentStudentName = "{{ current_student_name|escapejs }}";
    
        attachFileButton.addEventListener("click", function () {
            uploadMenu.style.display = uploadMenu.style.display === "none" ? "block" : "none";
        });
    
        document.addEventListener("click", function (event) {
            if (!attachFileButton.contains(event.target) && !uploadMenu.contains(event.target)) {
                uploadMenu.style.display = "none";
            }
        });
    
        uploadFileButton.addEventListener("click", function () {
            fileInput.click(); // Opens file picker
            uploadMenu.style.display = "none"; // Hide menu after clicking
        });
    
        fileInput.addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (!file) return;
    
        console.log("Selected file:", file);
    
        let isImage = file.type.startsWith("image/");
        let isVideo = file.type.startsWith("video/");
        let isOtherFile = !isImage && !isVideo;
    
        fileMessageContainer.style.display = "inline-block";
    
        const reader = new FileReader();
    
        reader.onload = function (e) {
            const fileData = e.target.result.split(",")[1]; // Base64 data
    
            document.getElementById("sendAttachedMessageButton").addEventListener("click", function () {
                const messageText = fileMessageInput.value.trim() || (isImage ? "My image" : "My file");
    
                const message = {
                    file: fileData,
                    message: messageText,
                    file_name: file.name,
                    file_type: file.type,
                    role: "student",
                    room_url: roomId,
                    sender: currentStudentName,
                    created_at: new Date().toISOString(),
                    is_file: true,
                    is_image: isImage,
                    is_video: isVideo,
                };
    
                console.log("Message being sent:", message);
                window.socket.send(JSON.stringify(message));
    
                fileMessageInput.value = "";
                fileMessageContainer.style.display = "none";
    
                console.log("Message sent!");
            });
        };
    
        reader.readAsDataURL(file); // Convert file to base64
    });
    
    
    
    
        // Handle Video Upload Click
        uploadVideoButton.addEventListener("click", function () {
            videoInput.click(); // Open the file picker for video files
            uploadMenu.style.display = "none"; // Hide the upload menu
        });
    
        videoInput.addEventListener("change", function (event) {
            const video = event.target.files[0]; // Get the selected video file
            if (!video) return; // Exit if no video is selected
    
            console.log("Selected video:", video);
    
            const videoType = video.type; // Get MIME type of the video
    
            // Check if it's a valid video file
            if (!videoType.startsWith("video/")) {
                console.log("This is not a valid video file.");
                alert("Please select a valid video file.");
                return;
            }
    
            fileMessageContainer.style.display = "inline-block";
    
            const reader = new FileReader();
    
            reader.onload = function (e) {
                const videoData = e.target.result.split(",")[1]; // Extract base64 data
    
                document.getElementById("sendAttachedMessageButton").addEventListener("click", function () {
                    const messageText = fileMessageInput.value.trim() || "My video"; // Default to "My video" if no message
    
                    const message = {
                        file: videoData,
                        message: messageText, // Attached message
                        file_name: video.name,
                        file_type: video.type,
                        role: "student",
                        room_url: roomId,
                        sender: currentStudentName,
                        created_at: new Date().toISOString(),
                        is_file: true,
                        is_video: true, // Flag indicating it's a video
                    };
    
                    console.log(message)
    
                    window.socket.send(JSON.stringify(message));
    
                    fileMessageInput.value = "";
                    fileMessageContainer.style.display = "none"; // Hide the message input
                });
            };
    
            reader.readAsDataURL(video); // Read as DataURL (base64)
        });
    
    
        document.getElementById("cancelMessageButton").addEventListener("click", function () {
            fileMessageInput.value = "";
            fileMessageContainer.style.display = "none"; // Hide the message input
        });
    
    });
    
    
    
        document.addEventListener("DOMContentLoaded", function () {
        if (window.socketInitialized) return;
        window.socketInitialized = true;
    
        const roomId = "{{ room_id|escapejs }}";
        const currentStudentName = "{{ current_student_name|escapejs }}";
        const userRole = "student";
    
        if (!roomId || !currentStudentName || !userRole) {
            console.error("Missing required variables.");
            return;
        }
    
        const socketURL = `ws://${window.location.host}/ws/${userRole}s-dashboard/hub-room/${roomId}/`;
    
        if (!window.socket || window.socket.readyState !== WebSocket.OPEN) {
            window.socket = new WebSocket(socketURL);
        } else {
            console.log("WebSocket already open.");
            return;
        }
    
        const socket = window.socket;
        const chatMessages = document.getElementById("chatMessages");
        const messageInput = document.getElementById("messageInput");
        const sendMessageButton = document.getElementById("sendMessageButton");
    
        const scrollToBottom = () => {
            if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
        };
    
        // Function to attach click event to a message element
        function attachMessageClickHandler(messageElement) {
            messageElement.addEventListener("click", function () {
                const messageContent = messageElement.dataset.message || messageElement.querySelector(".message-content").textContent;
                const messageId = messageElement.dataset.messageId;
                const roomId = "{{ room_id|escapejs }}";
    
                if (!messageId) {
                    console.error("Missing messageId:", messageElement);
                    return;
                }
    
                const newUrl = `/students-dashboard/hub-room/${roomId}/${messageId}`;
                window.history.pushState({ path: newUrl }, "", newUrl);
                openSidePanel(messageContent, messageId);
            });
        }
    
    
        function createMessageElement(sender, message, createdAt, role, messageId, imageUrl, fileUrl, videoUrl, pollOptions, roomUrl) {
        const newMessage = document.createElement("div");
        newMessage.className = "message-box";
        newMessage.dataset.message = message;
        newMessage.dataset.messageId = messageId;
    
        // Set appropriate class based on sender
        if (sender === currentUserName) {
            newMessage.classList.add(role === "teacher" ? "current-teacher-message" : "current-user-message");
        } else if (role === "teacher") {
            newMessage.classList.add("teacher-message");
        } else {
            newMessage.classList.add("other-user-message");
        }
    
        // Create sender span
        const senderSpan = document.createElement("span");
        senderSpan.className = "message-sender";
        senderSpan.textContent = sender === currentUserName ? "Me" : sender;
        newMessage.appendChild(senderSpan);
    
        // Handle image if present
        if (imageUrl) {
            const imgLink = document.createElement("a");
            imgLink.href = imageUrl;
            imgLink.target = "_blank";
            imgLink.className = "message-image";
    
            const imgElement = document.createElement("img");
            imgElement.src = imageUrl;
            imgElement.style.maxWidth = "400px";
            imgElement.style.height = "200px";
    
            imgLink.appendChild(imgElement);
            newMessage.appendChild(imgLink);
        }
    
        // Handle file if present
        if (fileUrl) {
            const fileDiv = document.createElement("div");
            fileDiv.className = "message-file";
    
            const fileLink = document.createElement("a");
            fileLink.href = fileUrl;
            fileLink.target = "_blank";
    
            const fileIcon = document.createElement("img");
            fileIcon.src = "https://cdn-icons-png.flaticon.com/512/337/337946.png";
            fileIcon.alt = "File";
            fileIcon.style.width = "100px";
            fileIcon.style.height = "100px";
    
            fileLink.appendChild(fileIcon);
            fileDiv.appendChild(fileLink);
            
            if (message && message !== "my file") {
                const messageText = document.createElement("span");
                messageText.textContent = message;
                fileDiv.appendChild(messageText);
            }
            
            newMessage.appendChild(fileDiv);
        }
    
        // Handle video if present
        else if (videoUrl) {
            const videoDiv = document.createElement("div");
            videoDiv.className = "message-video";
    
            const videoElement = document.createElement("video");
            videoElement.src = videoUrl;
            videoElement.controls = true;
            videoElement.style.maxWidth = "200px";
            videoElement.style.maxHeight = "200px";
    
            videoDiv.appendChild(videoElement);
            newMessage.appendChild(videoDiv);
        }
    
        // Handle poll if present
        else if (pollOptions) {
        // Use our enhanced poll display function
        const pollContainer = createPollElement(message, messageId, pollOptions, roomUrl);
        newMessage.appendChild(pollContainer);
    }
        else {
            // Plain text message
            const contentSpan = document.createElement("div");
            contentSpan.className = "message-text";
            contentSpan.textContent = message;
            newMessage.appendChild(contentSpan);
            
            // Add the top reply section for non-poll messages
            const topReplyDiv = document.createElement("div");
            topReplyDiv.className = "top-reply no-reply";
            
            const emText = document.createElement("em");
            emText.textContent = "No replies yet.";
            
            topReplyDiv.appendChild(emText);
            newMessage.appendChild(topReplyDiv);
        }
    
        // Add timestamp
        const timeSpan = document.createElement("span");
        timeSpan.className = "message-time";
        timeSpan.textContent = typeof createdAt === 'string' ? createdAt : 
                              (createdAt instanceof Date ? createdAt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 
                              new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
        newMessage.appendChild(timeSpan);
    
        // Add click event to open side panel for non-poll messages
        if (!pollOptions) {
            newMessage.addEventListener("click", function() {
                openSidePanel(message, messageId);
            });
        }
    
        return newMessage;
    }
    
    
    function createPollElement(message, messageId, pollOptions, roomUrl) {
        const pollContainer = document.createElement("div");
        pollContainer.classList.add("message-poll");
    
        const question = document.createElement("strong");
        question.textContent = message;
        pollContainer.appendChild(question);
    
        const form = document.createElement("form");
        form.id = `poll-form-${messageId}`;
        form.dataset.messageId = messageId;
        form.dataset.roomId = roomUrl;
    
        const optionsList = document.createElement("ul");
        optionsList.style.listStyle = "none";
        optionsList.style.padding = "0";
        optionsList.style.margin = "10px 0";
    
        // Calculate total votes for percentages
        let totalVotes = 0;
        pollOptions.forEach(option => {
            totalVotes += option.votes || 0;
        });
    
        pollOptions.forEach((option, index) => {
            const optionText = option.option;
            const votes = option.votes || 0;
            const percentage = totalVotes > 0 ? Math.round((votes / totalVotes) * 100) : 0;
    
            const optionItem = document.createElement("li");
            optionItem.style.margin = "8px 0";
            optionItem.style.padding = "5px";
    
            // Radio button for voting
            const radioContainer = document.createElement("div");
            radioContainer.style.display = "flex";
            radioContainer.style.alignItems = "center";
            radioContainer.style.marginBottom = "5px";
    
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.id = `option-${messageId}-${index + 1}`;
            radio.name = `poll-option-${messageId}`;
            radio.value = optionText;
            radio.style.marginRight = "8px";
    
            const label = document.createElement("label");
            label.htmlFor = `option-${messageId}-${index + 1}`;
            label.textContent = optionText;
            label.style.margin = "0";
            label.style.fontSize = "14px";
            label.style.cursor = "pointer";
    
            radioContainer.appendChild(radio);
            radioContainer.appendChild(label);
            optionItem.appendChild(radioContainer);
    
            // Results display
            const resultsContainer = document.createElement("div");
            
            // Option text and vote count
            const optionInfoDiv = document.createElement("div");
            optionInfoDiv.className = "poll-option-votes";
            
            const optionTextSpan = document.createElement("span");
            optionTextSpan.className = "poll-option-text";
            optionTextSpan.textContent = `${percentage}%`;
            
            const voteCountSpan = document.createElement("span");
            voteCountSpan.className = "poll-option-count";
            voteCountSpan.id = `vote-count-${messageId}-${index + 1}`;
            voteCountSpan.textContent = votes;
            
            optionInfoDiv.appendChild(optionTextSpan);
            optionInfoDiv.appendChild(voteCountSpan);
            resultsContainer.appendChild(optionInfoDiv);
            
            // Progress bar
            const progressBar = document.createElement("div");
            progressBar.className = "poll-results-bar";
            
            const progressFill = document.createElement("div");
            progressFill.className = "poll-results-fill";
            progressFill.style.width = `${percentage}%`;
            
            progressBar.appendChild(progressFill);
            resultsContainer.appendChild(progressBar);
            
            optionItem.appendChild(resultsContainer);
            optionsList.appendChild(optionItem);
        });
    
        form.appendChild(optionsList);
    
        const voteButton = document.createElement("button");
        voteButton.type = "button";
        voteButton.classList.add("poll-vote-button");
        voteButton.id = `poll-vote-${messageId}`;
        voteButton.textContent = "Vote";
        voteButton.style.marginTop = "10px";
        voteButton.onclick = function() {
            submitPollVote(messageId, roomUrl);
        };
    
        form.appendChild(voteButton);
        pollContainer.appendChild(form);
        
        return pollContainer;
    }
    
    
    
    socket.onopen = () => console.log("WebSocket connection established.");
    socket.onmessage = function (event) {
        try {
            const data = JSON.parse(event.data);
            const messageData = data.message;
    
            if (data.is_reply) {
                return;
            } else {
                if (messageData.question_id) {
                    return;
                } else {
                    const chatMessages = document.getElementById("chatMessages");
                    
                    // Format the timestamp
                    const formattedTime = new Date(messageData.created_at).toLocaleTimeString([], { 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        hour12: false 
                    });
                    
                    // Create the message element using our improved function
                    const newMessage = createMessageElement(
                        messageData.sender,
                        messageData.message,
                        formattedTime,
                        messageData.role || "student",
                        messageData.message_id,
                        messageData.image_url,
                        messageData.file_url,
                        messageData.video_url,
                        messageData.is_poll ? messageData.poll_options : null,
                        messageData.room_url || currentRoomId
                    );
                    
                    chatMessages.appendChild(newMessage);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }
        } catch (error) {
            console.error(" Error handling message for student:", error);
        }
    };
    
    
    
        socket.onerror = (error) => console.error("WebSocket error:", error);
        socket.onclose = () => console.log("WebSocket connection closed.");
    
        // Send message button event listener
        if (sendMessageButton && messageInput) {
            sendMessageButton.addEventListener("click", () => {
                const replyText = messageInput.value.trim();
                if (replyText) {
                    socket.send(
                        JSON.stringify({
                            message: replyText,
                            role: "student",
                            room_url: roomId,
                            sender: currentStudentName,
                            created_at: new Date().toISOString(),
                            reply:false
                        })
                    );
                    messageInput.value = "";
                } else {
                    alert("Please enter a message before sending.");
                }
            });
        }
    
        // Attach click event to existing messages on page load
        document.querySelectorAll(".message-box").forEach(attachMessageClickHandler);
    
        // Debugging: Log message IDs after loading
        setTimeout(() => {
            document.querySelectorAll(".message-box").forEach(msg => {
                console.log("Loaded Message ID:", msg.dataset.messageId);
            });
        }, 1000);
    
        scrollToBottom();
    });
    
    
    
    
    
    
let currentMessageId = null;
    
function openSidePanel(messageContent, messageId) {
    const sidePanel = document.getElementById('side-panel');
    const panelTitle = document.getElementById('panel-title');
    const chatSection = document.querySelector('.chat-section');
    const rightSidebar = document.querySelector('.right-sidebar');
    
    // Current sort method - initialized to 'recent' by default
    let currentSortMethod = 'recent';

    if (sidePanel.classList.contains('open')) {
        // Close the side panel
        sidePanel.classList.remove('open');
        chatSection.style.marginLeft = '0';
        rightSidebar.style.marginLeft = '0';

        // Reset the URL to remove messageId
        const newUrl = `/students-dashboard/hub-room/${currentRoomId}/`;
        window.history.pushState({ path: newUrl }, "", newUrl);

        // Reset the global messageId
        currentMessageId = null;
    } else {
        // Open the side panel
        
        // Set the title text with ellipsis handled by CSS
        panelTitle.textContent = messageContent;
        
        // Also set the title attribute for showing the full text on hover
        panelTitle.title = messageContent;
        
        sidePanel.classList.add('open');
        chatSection.style.marginLeft = '250px';
        rightSidebar.style.marginLeft = 'none';

        // Store the messageId in the global variable
        currentMessageId = messageId;

        // Load replies with the default sort method (recent)
        loadReplies(messageId, currentSortMethod);
        
        // Ensure sort buttons show the correct active state
        updateSortButtonState(currentSortMethod);

        // Check bookmark status and add listeners
        addBookmarkButtonListener();
    }
    
    // Function to load replies with the given sort method
    function loadReplies(messageId, sortMethod) {
        // Construct the URL with the sort parameter
        const newUrl = `/students-dashboard/hub-room/${currentRoomId}/${messageId}/?sort=${sortMethod}`;
        
        // Update browser URL without the query parameter
        const displayUrl = `/students-dashboard/hub-room/${currentRoomId}/${messageId}/`;
        window.history.pushState({ path: displayUrl }, "", displayUrl);

        // Show loading indicator
        const messagesArea = document.getElementById('sidePanelMessages');
        if (messagesArea) {
            messagesArea.innerHTML = '<div class="loading-replies">Loading replies...</div>';
        }

        // Fetch replies from the server with the sort parameter
        fetch(newUrl, {
            method: "GET",
            headers: {
                "X-Requested-With": "XMLHttpRequest"
            }
        })
        .then(response => response.json())
        .then(data => {
            console.log("Received messages:", data);
            if (messagesArea) {
                messagesArea.innerHTML = '';  // Clear existing messages
            }

            if (data.length === 0) {
                messagesArea.innerHTML = '<div class="no-replies">No replies yet. Be the first to reply!</div>';
                return;
            }

            // Iterate through the messages and append them to the side panel
            data.forEach(message => {
                const messageElement = document.createElement('div');
                messageElement.classList.add('side-panel-message');

                // Update content based on new design
                messageElement.innerHTML = `
                    <div class="reply">
                    <div class="reply-header">
                        <span class="reply-info">${message.sender}</span>
                        <span class="reply-role">(${message.role})</span>
                    </div>
                    <p class="reply-content">${message.reply_content}</p>
                    
                    <div class="reply-footer">
                        <button class="vote-button upvote" data-reply-id="${message.reply_id}">
                            <i class="fa fa-arrow-up"></i>
                        </button>
                        <span class="vote-count" id="vote-count-${message.reply_id}">
                            ${message.upvotes - message.downvotes}
                        </span>
                        <button class="vote-button downvote" data-reply-id="${message.reply_id}">
                            <i class="fa fa-arrow-down"></i>
                        </button>
                    </div>
                    </div>
                `;
                messagesArea.appendChild(messageElement);
            });

            // After appending all messages, attach vote handlers and fetch vote status
            attachVoteHandlers();
            fetchUserVotes();
        })
        .catch(error => {
            console.error("Error fetching message:", error);
            if (messagesArea) {
                messagesArea.innerHTML = '<div class="error-message">Error loading replies. Please try again.</div>';
            }
        });
    }

    // Setup sort button event listeners if side panel is opening
    if (!sidePanel.classList.contains('open')) {
        // Add listeners to sort buttons if not already added
        const sortButtons = document.querySelectorAll('.sort-button');
        sortButtons.forEach(button => {
            // Remove existing listeners to prevent duplicates
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            // Add new listener
            newButton.addEventListener('click', function() {
                const sortMethod = this.getAttribute('data-sort');
                
                // Skip if already using this sort method
                if (sortMethod === currentSortMethod) return;
                
                // Update current sort method
                currentSortMethod = sortMethod;
                
                // Update active button state
                updateSortButtonState(sortMethod);
                
                // Reload replies with new sort method
                loadReplies(currentMessageId, currentSortMethod);
            });
        });
    }
    
    // Function to update the active state of sort buttons
    function updateSortButtonState(activeMethod) {
        const sortButtons = document.querySelectorAll('.sort-button');
        sortButtons.forEach(button => {
            if (button.getAttribute('data-sort') === activeMethod) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
    }
}
    
    function addBookmarkButtonListener() {
        const bookmarkButton = document.getElementById('bookmark-button');
    
        if (bookmarkButton) {
            // First, check if the bookmark status and update button UI accordingly
            checkBookmarkStatus();
            
            // Remove any existing event listener to prevent duplicates
            bookmarkButton.removeEventListener('click', handleBookmarkClick);
            
            // Add the event listener
            bookmarkButton.addEventListener('click', handleBookmarkClick);
        } else {
            console.error("Bookmark button not found");
        }
    }
    
    // Function to check if a question is already bookmarked
    function checkBookmarkStatus() {
        const bookmarkButton = document.getElementById('bookmark-button');
        const username = currentUserName; // Make sure this variable is defined in your context
        const questionId = currentMessageId;
        const roomId = currentRoomId; // Make sure this variable is defined in your context
        
        if (!questionId) return;
        
        fetch("/check-bookmark-status/", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ username, questionId, roomId })
        })
        .then(response => response.json())
        .then(data => {
            if (data.is_bookmarked) {
                bookmarkButton.classList.add('bookmarked');
            } else {
                bookmarkButton.classList.remove('bookmarked');
            }
        })
        .catch(error => {
            console.error('Error checking bookmark status:', error);
        });
    }
    
    // Event handler for bookmark button clicks
    function handleBookmarkClick() {
        const username = currentUserName; // Make sure this variable is defined
        const questionId = currentMessageId;
        const roomId = currentRoomId; // Make sure this variable is defined
        const button = this;
        
        if (!questionId) {
            showToast("Error: Cannot identify the question to bookmark", "error");
            return;
        }
        
        button.disabled = true; // Prevent multiple clicks
        
        if (button.classList.contains('bookmarked')) {
            removeBookmark(username, questionId, roomId, button);
        } else {
            addBookmark(username, questionId, roomId, button);
        }
    }
    
    function removeBookmark(username, questionId, roomId, button) {
        showToast("Removing bookmark...", "info");
        
        fetch("/remove-bookmark-queston/", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ username, questionId, roomId })
        })
        .then(response => response.json())
        .then(data => {
            button.disabled = false;
            if (data.message === 'Bookmark removed successfully!') {
                button.classList.remove('bookmarked');
                showToast("Removed from bookmarks", "success");
            } else {
                showToast("Failed to remove bookmark", "error");
                console.error('Failed to remove bookmark:', data.error);
            }
        })
        .catch(error => {
            button.disabled = false;
            showToast("Network error", "error");
            console.error('Error removing bookmark:', error);
        });
    }
    
    function addBookmark(username, questionId, roomId, button) {
        showToast("Adding bookmark...", "info");
        
        fetch("/bookmark-questions/", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ username, questionId, roomId })
        })
        .then(response => response.json())
        .then(data => {
            button.disabled = false;
            if (data.message === 'Already bookmarked!') {
                button.classList.add('bookmarked');
                showToast("Already in your bookmarks", "info");
            } else if (data.message === 'Bookmark saved successfully!') {
                button.classList.add('bookmarked');
                showToast("Added to bookmarks", "success");
            } else {
                showToast("Failed to add bookmark", "error");
                console.error('Failed to add bookmark:', data.error);
            }
        })
        .catch(error => {
            button.disabled = false;
            showToast("Network error", "error");
            console.error('Error adding bookmark:', error);
        });
    }
    
    // A better toast notification system
    function showToast(message, type) {
        // Remove any existing toast
        const existingToast = document.getElementById('toast-notification');
        if (existingToast) {
            existingToast.remove();
        }
        
        // Create toast container if it doesn't exist
        let toastContainer = document.getElementById('toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.id = 'toast-container';
            toastContainer.style.position = 'fixed';
            toastContainer.style.bottom = '20px';
            toastContainer.style.right = '20px';
            toastContainer.style.zIndex = '9999';
            document.body.appendChild(toastContainer);
        }
        
        // Create toast
        const toast = document.createElement('div');
        toast.id = 'toast-notification';
        toast.style.backgroundColor = type === 'error' ? '#f44336' : 
                                      type === 'success' ? '#4CAF50' : 
                                      type === 'info' ? '#2196F3' : '#333';
        toast.style.color = 'white';
        toast.style.padding = '16px';
        toast.style.borderRadius = '4px';
        toast.style.marginTop = '10px';
        toast.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        toast.style.minWidth = '250px';
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        toast.textContent = message;
        
        // Add toast to container
        toastContainer.appendChild(toast);
        
        // Fade in
        setTimeout(() => {
            toast.style.opacity = '1';
        }, 10);
        
        // Fade out after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }
    
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    
    
    
    
    let socket;
    const roomId = "{{ room_id|escapejs }}";
    const socketUrl = `ws://${window.location.host}/ws/students-dashboard/hub-room/${roomId}/`;
    
    function initializeWebSocket() {
        if (!socket || socket.readyState === WebSocket.CLOSED) {
            socket = new WebSocket(socketUrl);
    
            socket.onopen = function () {
                console.log(" WebSocket connection established.");
            };
    
            socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const messageData = data.message;
    
                    console.log(" Received messageData:", messageData);
    
                    if (messageData && messageData.question_id) {
                        console.log(" Processing reply:", messageData);
    
                        const replyText = messageData.message || "No reply content";
                        const messagesArea = document.getElementById('sidePanelMessages');
    
                        // Create reply element
                        const messageElement = document.createElement('div');
                        messageElement.classList.add('side-panel-message');
                        messageElement.innerHTML = `
                            <div class="reply">
                                <div class="reply-header">
                                    <span class="reply-info">${messageData.sender}</span>
                                    <span class="reply-role">(${messageData.role})</span>
                                </div>
                                <p class="reply-content">${replyText}</p>
                                <div class="reply-footer">
                                    <button class="vote-button upvote" data-reply-id="${messageData.reply_id}">
                                        <i class="fa fa-arrow-up"></i>
                                    </button>
                                    <span class="vote-count" id="vote-count-${messageData.reply_id}">
                                        ${messageData.upvotes - messageData.downvotes}
                                    </span>
                                    <button class="vote-button downvote" data-reply-id="${messageData.reply_id}">
                                        <i class="fa fa-arrow-down"></i>
                                    </button>
                                </div>
                            </div>
                        `;
    
                        messagesArea.appendChild(messageElement);
    
                        messageElement.querySelectorAll(".vote-button").forEach(button => {
                            button.addEventListener("click", function () {
                                const replyId = this.dataset.replyId;
                                const voteType = this.classList.contains("upvote") ? "up" : "down";
                                vote(replyId, voteType); // Call your vote function
                            });
                        });
    
                    } else {
                        console.log(" Not a reply, ignoring.");
                    }
                } catch (error) {
                    console.error(" Error handling message:", error);
                }
            };
    
            socket.onerror = (e) => console.error(" WebSocket error:", e);
            socket.onclose = (e) => console.log(" WebSocket closed:", e);
        }
    }
    
    // Initialize WebSocket on page load
    initializeWebSocket();
    
    document.getElementById('sidePanelSendButton').addEventListener('click', function () {
        const inputField = document.getElementById('sidePanelInput');
        const replyText = inputField.value.trim();
    
        if (!replyText) {
            alert('Please enter a message before sending.');
            return;
        }
    
        if (!currentMessageId) {
            alert("Message ID is missing!");
            return;
        }
    
        inputField.value = ''; // Clear the input field
    
        const sender = "{{ current_student_name|escapejs }}";  
        const createdAt = new Date().toISOString();  
        const messageType = "text";  
        const upvotes = 0;  
        const downvotes = 0;  
    
        const messageData = {
            question_id: currentMessageId,
            message: replyText,
            sender: sender,
            created_at: createdAt,
            message_type: messageType,
            upvotes: upvotes,
            downvotes: downvotes,
            room_url: roomId,
            role: "STUDENT",
            reply: true
        };
    
        // Ensure WebSocket is open before sending
        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(messageData));
        } else {
            console.error("WebSocket is not open. Reconnecting...");
            initializeWebSocket(); // Reinitialize if needed
            setTimeout(() => {
                if (socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify(messageData));
                    console.log("I have sent the reply")
                } else {
                    console.error("WebSocket connection failed.");
                }
            }, 500); 
        }
    });
    
    document.addEventListener('DOMContentLoaded', function() {
        // Check if there's a questionId in sessionStorage
        const questionId = sessionStorage.getItem('openQuestionId');
        
        if (questionId) {
            console.log("I am here now, it will work")
            // Clear it from session storage so it doesn't trigger again on refresh
            sessionStorage.removeItem('openQuestionId');
            
            // Find the message box with this question ID
            const messageBox = document.querySelector(`.message-box[data-message-id="${questionId}"]`);
            
            if (messageBox) {
                // Get the message content
                const messageContent = messageBox.getAttribute('data-message') || messageBox.textContent.trim();
                
                // Wait a moment for everything to load, then open the side panel
                setTimeout(() => {
                    // Open the side panel with this message
                    openSidePanel(messageContent, questionId);
                    
                    // Scroll to the message
                    messageBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Highlight the message temporarily
                    messageBox.style.boxShadow = '0 0 15px rgba(0, 123, 255, 0.7)';
                    setTimeout(() => {
                        messageBox.style.boxShadow = '';
                    }, 3000);
                }, 1000);
            } else {
                console.error(`Message with ID ${questionId} not found`);
            }
        }
    });
    </script>
</body>
</html>